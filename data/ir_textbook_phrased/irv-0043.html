threaded lists in this section an elementary knowledge of list-processing will be assumed . readers who are unfamiliar with this topic should consult the little book by foster [20] . a simple list representation of the classification ((d1 , d2) , (d3 , d4)) , ((d5 , d6) , (d7 , d8)) is given in figure 4.10 . each sublist in this structure has associated with it a record containing only two pointers . (we can assume that di is really a pointer to document di .) the function of the pointers should be clear from the diagram . the main thing to note , however , is that the record associated with a list does not contain any identifying information . a modification of the implementation of a list structure like this which makes it resemble a set of ring structures is to make the right hand pointer of the last element of a sublist point back to the head of the sublist . each sublist has become effectively a ring structure . we now have what is commonly called a threaded list (see figure 4.11) . the representation i have given is a slight oversimplification in that we need to flag which elements are data elements (giving access to the documents di) and which elements are just pointer elements . the major advantage associated with a threaded list is that it can be traversed without the aid of a stack . normally when traversing a conventional list structure the return addresses are stacked , whereas in the threaded list they have been incorporated in the data-structure . one disadvantage associated with the use of list and ring structures for representing classifications is that they can only be entered at the ` top ' . an additional index giving entry to the structure at each of the data elements increases the update speed considerably . another modification of the simple list representation has been studied extensively by stanfel [21,22] and patt [23] . the individual elements (or cells) of the list structure are modified to incorporate one extra field , so that instead of each element looking like this where the pis are pointers and s is a symbol . otherwise no essential change has been made to the simple representation . this structure has become known as the doubly chained tree . its properties have mainly been investigated for storing variable-length keys , where each key is made up by selecting symbols from a finite (usually small) alphabet . for example , let {a , b , c} be the set of key symbols and let r1 , r2 , r3 , r4 , r5 be five records to be stored . let us assign keys made of the 3 symbols , to the record as follows : aaa r1 ab r2 ac r3 bb r4 bc r5 an example of a doubly chained tree containing the keys and giving access to the records is given in figure 4.12 . the topmost element contains no symbol , it merely functions as the start of the structure . given an arbitrary key its presence or absence is detected by matching it against keys in the structure . matching proceeds level by level , once a matching symbol has been found at one level , the p1 pointer is followed to the set of alternative symbols at the next level down . the matching will terminate either : (1) when the key is exhausted , that is , no more key symbols are left to match ; or (2) when no matching symbol is found at the current level . for case (1) we have : (a) the key is present if the p1 pointer in the same cell as the last matching symbol now points to a record ; (b) p1 points to a further symbol , that is , the key ` falls short ' and is therefore not in the structure . for case (2) , we also have that the key is not in the structure , but now there is a mismatch . stanfel and patt have concentrated on generating search-trees with minimum expected search-time , and preserving this property despite updating . for the detailed mathematics demonstrating that this is possible the reader is referred to their cited work .