a vector-space-model for xml-retrieval figure 10.8 : a mapping of an xml-document (left) to a set of lexicalized subtrees (right) . to take account of structure in retrieval in figure 10.4 , we want a book entitled julius caesar to be a match for and no match (or a lower weighted match) for . in unstructured retrieval , there would be a single dimension of the vector-space for caesar . in xml-retrieval , we must separate the title word caesar from the author name caesar . one way of doing this is to have each dimension of the vector-space encode a word together with its position within the xml-tree . figure 10.8 illustrates this representation . we first take each text node (which in our setup is always a leaf) and break it into multiple-nodes , one for each word . so the leaf node bill gates is split into two leaves bill and gates . next we define the dimensions of the vector-space to be lexicalized subtrees of documents - subtrees that contain at least one vocabulary term . a subset of these possible lexicalized subtrees is shown in the figure , but there are others - e.g. , the subtree corresponding to the whole document with the leaf node gates removed . we can now represent queries and documents as vectors in this space of lexicalized subtrees and compute matches between them . this means that we can use the vector-space formalism from chapter 6 for xml-retrieval . the main difference is that the dimensions of vector-space in unstructured retrieval are vocabulary terms whereas they are lexicalized subtrees in xml-retrieval . there is a tradeoff between the dimensionality of the space and accuracy of query results . if we trivially restrict dimensions to vocabulary terms , then we have a standard vector-space-retrieval system that will retrieve many documents that do not match the structure of the query (e.g. , gates in the title as opposed to the author element) . if we create a separate dimension for each lexicalized subtree occurring in the collection , the dimensionality of the space becomes too large . a compromise is to index all paths that end in a single vocabulary term , in other words , all xml-contextterm pairs . we call such an xml-contextterm pair a structural term and denote it by : a pair of xml-context and vocabulary term . the document in figure 10.8 has nine structural terms . seven are shown (e.g. , `` bill '' and author # `` bill '') and two are not shown : / book/author # `` bill '' and / book/author # `` gates '' . the tree with the leaves bill and gates is a lexicalized subtree that is not a structural term . we use the previously introduced pseudo-xpath notation for structural terms . as we discussed in the last section users are bad at remembering details about the schema and at constructing queries that comply with the schema . we will therefore interpret all queries as extended queries - that is , there can be an arbitrary number of intervening nodes in the document for any parent-child node pair in the query . for example , we interpret in figure 10.7 as . but we still prefer documents that match the query-structure closely by inserting fewer additional nodes . we ensure that retrieval results respect this preference by computing a weight for each match . a simple measure of the similarity of a path in a query and a path in a document is the following context resemblance function cr : (52) 10.6 the final score for a document is computed as a variant of the cosine-measure (equation 24 , page 6.3.1) , which we call simnomerge for reasons that will become clear shortly . simnomerge is defined as follows : (53) 6 10.2 10.7 6.3.1 6.3.1 figure 10.9 : the algorithm for scoring documents with s imn om erge . im o erge 10.9 normalizer 10.9 53 figure 10.10 : scoring of a query with one structural term in s imn om erge . we give an example of how simnomerge computes query-document similarities in figure 10.10 . is one of the structural terms in the query . we successively retrieve all postings lists for structural terms with the same vocabulary term . three example postings lists are shown . for the first one , we have since the two contexts are identical . the next context has no context resemblance with : and the corresponding postings list is ignored . the context match of with is 0.63 > 0 and it will be processed . in this example , the highest ranking document is with a similarity of . to simplify the figure , the query weight of is assumed to be 1.0 . the query-document similarity-function in figure 10.9 is called simnomerge because different xml contexts are kept separate for the purpose of weighting . an alternative similarity-function is simmerge which relaxes the matching conditions of query and document further in the following three ways . we collect the statistics used for computing and from all contexts that have a non-zero resemblance to (as opposed to just from as in simnomerge) . for instance , for computing the document frequency of the structural term atl # `` recognition '' , we also count occurrences of recognition in xml contexts fm/atl , article / / atl etc. . we modify equation 53 by merging all structural terms in the document that have a non-zero context resemblance to a given query structural term . for example , the contexts / play/act/scene / title and / play/title in the document will be merged when matching against the query-term / play/title # `` macbeth '' . the context resemblance function is further relaxed : contexts have a non-zero resemblance in many cases where the definition of cr in equation 52 returns 0 . 10.6 these three changes alleviate the problem of sparse term statistics discussed in section 10.2 and increase the robustness of the matching-function against poorly posed structural queries . the evaluation of simnomerge and simmerge in the next section shows that the relaxed matching conditions of simmerge increase the effectiveness of xml-retrieval . exercises . consider computing df for a structural term as the number of times that the structural term occurs under a particular parent node . assume the following : the structural term author # `` herbert '' occurs once as the child of the node squib ; there are 10 squib nodes in the collection ; occurs 1000 times as the child of article ; there are 1,000,000 article nodes in the collection . the idf weight of then is when occurring as the child of squib and when occurring as the child of article . (i) explain why this is not an appropriate weighting for . why should not receive a weight that is three times higher in articles than in squibs ? (ii) suggest a better way of computing idf . write down all the structural terms occurring in the xml-document in figure 10.8 . how many structural terms does the document in figure 10.1 yield ?