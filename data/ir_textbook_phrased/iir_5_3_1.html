variable byte codes vb encoding . gaps are encoded using an integral number of bytes . the first bit , the continuation bit , of each byte indicates whether the code ends with this byte (1) or not (0) . docids 824 829 215406 gaps 5 214577 vb code 00000110 10111000 10000101 00001101 00001100 10110001 variable byte (vb) encoding uses an integral number of bytes to encode a gap . the last 7 bits of a byte are `` payload '' and encode part of the gap . the first bit of the byte is a continuation bit . it is set to 1 for the last byte of the encoded gap and to 0 otherwise . to decode a variable byte-code , we read a sequence of bytes with continuation bit 0 terminated by a byte with continuation bit 1 . we then extract and concatenate the 7-bit parts . figure 5.8 gives pseudocode for vb encoding and decoding and table 5.4 an example of a vb-encoded postings list . with vb compression , the size of the compressed index for reuters-rcv1 is 116 mb as we verified in an experiment . this is a more than 50 % reduction of the size of the uncompressed index (see table 5.6) . the idea of vb encoding can also be applied to larger or smaller units than bytes : 32-bit words , 16-bit words , and 4-bit words or nibbles . larger words further decrease the amount of bit-manipulation necessary at the cost of less effective (or no) compression . word sizes smaller than bytes get even better compression ratios at the cost of more bit-manipulation . in general , bytes offer a good compromise between compression-ratio and speed of decompression . for most ir systems variable byte codes offer an excellent tradeoff between time and space . they are also simple to implement - most of the alternatives referred to in section 5.4 are more complex . but if disk space is a scarce resource , we can achieve better compression ratios by using bit-level encodings , in particular two closely related encodings : codes , which we will turn to next , and codes (exercise 5.3.2) .