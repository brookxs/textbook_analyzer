trees although computer scientists have adopted trees as file-structures , their properties were originally investigated by mathematicians . in fact , a substantial part of the theory of graphs is devoted to the study of trees . excellent books on the mathematical aspects of trees (and graphs) have been written by berge [24] , harary et al. , [25] and ore [26] . harary 's book also contains a useful glossary of concepts in graph-theory . in addition bertziss [3] and knuth [27] discuss topics in graph-theory with applications in information-processing . there are numerous definitions of trees . i have chosen a particularly simple one from berge . if we think of a graph as a set of nodes (or points or vertices) and a set of lines (or edges) such that each line connects exactly two nodes , then a tree is defined to be a finite connected graph with no cycles , and possessing at least two nodes . to define a cycle we first define a chain . we represent the line uk joining two nodes x and y by uk = [x , y] . a chain is a sequence of lines , in which each line uk has one node in common with the preceding line uk-1 , and the other vertex in common with the succeeding line uk +1 . an example of a chain is [a , x1] , [x1 , x2] , [x2 , x3] , [x3 , b] . a cycle is a finite chain which begins at a node and terminates at the same node (i.e. in the example a = b) . berge gives the following theorem showing many equivalent characterisations of trees . theorem . let h be a graph with at least n nodes , where n gt ; 1 ; any one of the following equivalent properties characterises a tree . (1) h is connected and does not possess any cycles . (2) h contains no cycles and has n - 1 lines . (3) h is connected and has n - l lines . (4) h is connected but loses this property if any line is deleted . (5) every pair of nodes is connected by one and only one chain . one thing to be noticed in the discussion so far is that no mention has been made of a direction associated with a line . in most applications in computer-science (and ir) one node is singled out as special . this node is normally called the root of the tree , and every other node in the tree can only be reached by starting at the root and proceeding along a chain of lines until the node sought is reached . implicitly therefore , a direction is associated with each line . in fact , when one comes to represent a tree inside a computer by a list structure , often the addresses are stored in a way which allows movement in only one direction . it is convenient to think of a tree as a directed-graph with a reserved node as the root of the tree . of course , if one has a root then each path (directed chain) starting at the root will eventually terminate at a particular node from which no further branches will emerge . these nodes are called the terminal nodes of the tree . by now it is perhaps apparent that when we were talking about ring structures and threaded lists in some of our examples we were really demonstrating how to implement a tree-structure . the dendrogram in figure 4.7 can easily be represented as a tree (figure 4.13) . the documents are stored at the terminal nodes and each node represents a class (cluster) of documents . a search for a particular set of documents would be initiated at the root and would proceed along the arrows until the required class was found . another example of a tree-structure is the directory associated with an index-sequential file . it was described as a hierarchy of indexes , but could equally well have been described as a tree-structure . the use of tree-structures in computer-science dates back to the early 1950s when it was realised that the so-called binary-search could readily be represented by a binary-tree . a binary-tree is one in which each node (except the terminal nodes) has exactly two branches leaving it . a binary-search is an efficient method for detecting the presence or absence of a key value among a set of keys . it presupposes that the keys have been sorted . it proceeds by successive division of the set , at each division discarding half the current set as not containing the sought key . when the set contains n sorted keys the search-time is of order log2n . furthermore , after some thought one can see how this process can be simply represented by a binary-tree . unfortunately , in many applications one wants the ability to insert a key which has been found to be absent . if the keys are stored sequentially then the time taken by the insertion operation may be of order n . if one , however , stores the keys in a binary-tree this lengthy insert time may be overcome , both search and insert time will be of order log2n . the keys are stored at the nodes , at each node a left branch will lead to ` smaller ' keys , a right branch will lead to ` greater ' keys . a search terminating on a terminal node will indicate that the key is not present and will need to be inserted . the structure of the tree as it grows is largely dependent on the order in which new keys are presented . search-time may become unnecessarily long because of the lop-sidedness of the tree . fortunately , it can be shown (knuth [28]) that random insertions do not change the expected log2n time dependence of the tree search . nevertheless , methods are available to prevent the possibility of degenerate trees . these are trees in which the keys are stored in such a way that the expected search-time is far from optimal . for example , if the keys were to arrive for insertion already ordered then the tree to be built would simply be as shown in figure 4.14 . it would take us too far afield for me to explain the techniques for avoiding degenerate trees . essentially , the binary tree is maintained in such a way that at any node the subtree on the left branch has approximately as many levels as the subtree on the right branch . hence the name balanced-tree for such a tree . the search paths in a balanced-tree will never be more than 45 per cent longer than the optimum . the expected search and insert times are still of order log n. for further details the reader is recommended to consult knuth [28] . so far we have assumed that each key was equally likely as a search argument . if one has data giving the probability that the search argument is ki (a key already in the tree) , and the probability that the search argument lies between ki and ki +1 , then again techniques are known for reordering the tree to optimise the expected search-time . essentially one makes sure that the more frequently accessed keys have the shortest search paths from the root . one well-known technique used when only the second set of probabilities is known , and the others assigned the value zero , is the hu-tucker algorithm . again the interested reader may consult knuth . at this point it is probably a good idea to point out that these efficiency considerations are largely irrelevant when it comes to representing a document-classification by a tree-structure . the situation in document-retrieval is different in the following aspects : (1) we do not have a useful linear-ordering on the documents ; (2) a search request normally does not seek the absence or presence of a document . in fact , what we do have is that documents are more or less similar to each other , and a request seeks documents which in some way best match the request . a tree-structure representing a document-classification is therefore chosen so that similar documents may be close together . therefore to rearrange a tree-structure to satisfy some ` balancedness ' criterion is out of the question . the search efficiency is achieved by bringing together documents which are likely to be required together . this is not to say that the above efficiency considerations are unimportant in the general context of ir . many operations , such as the searching of a dictionary , and using a suffix-stripping algorithm can be made very efficient by appropriately structuring the binary tree . the discussion so far has been limited to binary-trees . in many applications this two-way split is inappropriate . the natural way to represent document classifications is by a general tree-structure , where there is no restriction on the number of branches leaving a node . another example is the directory of an index-sequential file which is normally represented by an m-way tree , where m is the number of branches leaving a node . finally , more comments are in order about the manipulation of tree-structures in mass-storage devices . up to now we have assumed that to follow a set of pointers poses no particular problems with regard to retrieval speed . unfortunately , present random-access devices are sufficiently slow for it to be impossible to allow an access for , say , each node in a tree . there are ways of partitioning trees in such a way that the number of disk accesses during a tree-search can be reduced . essentially , it involves storing a number of nodes together in one ` page ' of disk-storage . during a disk access this page is brought into fast memory , is then searched , and the next page to be accessed is determined .