8.3.2 signature-files signature-files are word-oriented index-structures based on hashing . they pose a low-overhead (10 % to 20 % over the text size) , at the cost of forcing a sequential search over the index . however , although their search complexity is linear (instead of sublinear as with the previous approaches) , its constant is rather low , which makes the technique suitable for not very-large texts . nevertheless , inverted-files outperform signature-files for most applications . structure a signature-file uses a hash-function (or ` signature ') that maps words to bit masks of b bits . it divides the text in blocks of b words each . to each text block of size 6 , a bit mask of size b will be assigned . this mask is obtained by bitwise oring the signatures of all the words in the text block . hence , the signature-file is no more than the sequence of bit masks of all blocks (plus a pointer to each block) . the main idea is that if a word is present in a text block , then all the bits set in its signature are also set in the bit mask of the text block . hence , whenever a bit is set in the mask of the query word and not in the mask of the text block , then the word is not present in the text block . figure 8.11 shows an example . however , it is possible that all the corresponding bits are set even though the word is not there . this is called a false drop . the most delicate part of the design of a signature-file is to ensure that the probability of a false drop is low enough while keeping the signature-file as short as possible . the hash-function is forced to deliver bit masks which have at least # bits set . a good model assumes that # bits are randomly set in the mask (with passible repetition) . let a = # / b . since each of the b words sets # bits at 206 indexing and searching block 1 block 2 block 3 block 4 this is a text . a text has many words . words are made from letters . 000101 110101 100100 101101 text text signature h (text) = 000101 h (many) = 110000 h (words) = 100100 h (made) = 001100 h (letters) = 100001 signature function figure 8.11 a signature-file for our sample text cut into blocks . random , the probability that a given bit of the mask is set in a word signature is 1 - (1 - l/b) m ´ 1 - e ~ ba . hence , the probability that the # random bits set in the query are also set in the mask of the text block is which is minimized for a = ln (2) / 6 . the false drop-probability under the optimal selection # = bln (2) / b is (i/2ln ´ 2)) 5/6 = 1/2 * . hence , a reasonable proportion b/b must be determined . the space-overhead of the index is approximately (1/80) x (b/b) because b is measured in bits and b in words . then , the false drop-probability is a function of the overhead to pay . for instance , a 10 % overhead implies a false drop-probability close to 2 % , while a 20 % overhead errs with probability 0.046 % . this error-probability corresponds to the expected amount of sequential-searching to perform while checking if a match is a false drop or not . searching searching a single word is carried out by hashing it to a bit mask w , and then comparing the bit masks b % of all the text blocks . whenever (w b {= w) , where is the bitwise and , all the bits set in w are also set in b % and therefore the text block may contain the word . hence , for all candidate text blocks , an online traversal must be performed to verify if the word is actually there . this traversal can not be avoided as in inverted-files (except if the risk of a false drop is accepted) . no other types of patterns can be searched in this scheme . on the other hand , the scheme is more efficient to search phrases and reasonable proximity-queries . this is because all the words must be present in a block in order for that block to hold the phrase or the proximity-query . hence , the bitwise or of all the query masks is searched , so that all their bits must be present . this boolean-queries 207 reduces the probability of false drops . this is the only indexing-scheme which improves in phrase-searching . some care has to be exercised at block boundaries , however , to avoid missing a phrase which crosses a block limit . to allow searching phrases of j words or proximities of up to j words , consecutive blocks must overlap in j words . if the blocks correspond to retrieval units , simple boolean conjunctions involving words or phrases can also be improved by forcing all the relevant words to be in the block . we were only able to find real performance-estimates from 1992 , run on a sun 3/50 with local disk . queries on a small 2.8 mb database took 0.42 seconds . extrapolating to today 's technology , we find that the performance should be close to 20 mb/sec (recall that it is linear-time) , and hence the example of 250 mb of text would take 12 seconds , which is quite slow . construction the construction of a signature-file is rather easy . the text is simply cut in blocks , and for each block an entry of the signature-file is generated . this entry is the bitwise or of the signatures of all the words in the block . adding text is also easy , since it is only necessary to keep adding records to the signature-file . text deletion is carried out by deleting the appropriate bit masks . other storage proposals exist apart from storing all the bit masks in sequence . for instance , it is possible to make a different file for each bit of the mask , i.e. one file holding all the first bits , another file for all the second bits , etc. . this reduces the disk times to search for a query , since only the files corresponding to the # bits which are set in the query have to be traversed .