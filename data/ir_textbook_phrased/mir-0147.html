8.5.4 shift-or shift-or is based on hit-parallelism . this technique involves taking advantage of the intrinsic parallelism of the bit operations inside a computer word (of w bits) . by cleverly using this fact , the number of operations that an algorithm performs can be cut by a factor of at most w . since in current architectures w is 32 or 64 . the speedup is very significant in practice . the shift-or algorithm uses bit-parallelism to simulate the operation of a non-deterministic automaton that searches the pattern in the text (see figure 3.17) . as this automaton is simulated in time o (mn) , the shift-or algorithm achieves o (ninfir) worst-case time (optimal speedup) . the algorithm first builds a table b which for each character stores a bit mask hm ... bi . the mask in b [c] has the i-th bit set to zero if-and-only-if sequential-searching 213 gt ; x - n c ï - gt ; m -- n d / ó a óªï © b [a} = 1 0 0 1 0 1 0 1 0 0 1 b [b] = 0 1 0 0 0 0 0 0 1 0 0 sw = 0 0 1 0 0 0 0 0 0 1 0 b [c] = 0 0 0 0 1 0 0 0 0 0 0 b [d] = 0 0 0 0 0 0 1 0 0 0 0 b \*] = 0 0 0 0 0 0 0 0 0 0 0 figure 8.17 non-deterministic automaton that searches ` abracadabra ,1 and the associated b table . the initial self-loop matches any character . each table column corresponds to an edge of the automaton . pi = c (see figure 8.17) . the state of the search is kept in a machine word d = dm ... di , where d {is zero whenever the state numbered i in figure 8.17 is active . therefore , a match is reported whenever dm is zero . in the following , we use to denote the bitwise or and c ' to denote the bitwise and . d is set to all ones originally , and for each new text character t3 , d is updated using the formula d' lt ; - (# gt ; ´ 1) | b [tj] (where ` lt ; lt ; ' means shifting all the bits in d one position to the left and setting the rightmost bit to zero) . it is not hard to relate the formula to the movement that occurs in the non-deterministic automaton for each new text character . for patterns longer than the computer word (i.e. , m gt ; ir) , the algorithm uses \ m/w '] computer words for the simulation (not all them are active all the time) . the algorithm is o (n) on average and the preprocessing is o (m + a) time and o (cr) space . it is easy to extend shift-or to handle classes of characters by manipulating the b table and keeping the search-algorithm unchanged . this paradigm also can search a large set of extended patterns , as well as multiple-patterns (where the complexity is the same as before if we consider that m is the total length of all the patterns) .