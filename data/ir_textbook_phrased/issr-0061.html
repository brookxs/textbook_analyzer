data-structure 93 4.6 signature-file structure the goal of a signature-file structure is to provide a fast test to eliminate the majority of items that are not related to a query . the items that satisfy the test can either be evaluated by another search-algorithm to eliminate additional false hits or delivered to the user to review . the text of the items is represented in a highly compressed form that facilitates the fast test . because file-structure is highly compressed and unordered , it requires significantly less space than an inverted-file structure and new items can be concatenated to the end of the structure versus the significant inversion list update . since items are seldom deleted from information data-bases , it is typical to leave deleted items in place and mark them as deleted . signature-file search is a linear scan of the compressed version of items producing a response-time linear with respect to file-size . the surrogate signature search file is created via superimposed coding (faloutsos-85 , moders-49) . the coding is based upon words in the item . the words are mapped into a `` word signature . '' a word signature is a fixed length code with a fixed number of bits set to `` 1 . '' the bit positions that are set to one are determined via a hash-function of the word . the word signatures are ored together to create the signature of an item . to avoid signatures being too dense with `` l `` s , a maximum number of words is specified and an item is partitioned into blocks of that size . in figure 4.13 the block-size is set at five words , the code length is 16 bits and the number of bits that are allowed to be `` 1 '' for each word is five . text : computer-science graduate-students study (assume block-size is five words) word signature computer 0001 0110 0000 0110 science 1001 0000 1110 0000 graduate 1000 0101 0100 0010 students 0000 0111 1000 0100 study 0000 0110 0110 0100 block signature 1001 0111 1110 0110 figure 4.13 superimposed coding the words in a query are mapped to their signature . search is accomplished by template-matching on the bit positions specified by the words in the query . the signature-file can be stored as a signature with each row representing a signature block . associated with each row is a pointer to the original text block . a design objective of a signature-file system is trading-off the size of the data 94 chapter 4 structure versus the density of the final created signatures . longer code lengths reduce the probability of collision in hashing the words (i.e. , two different words hashing to the same value) . fewer bits per code reduce the effect of a code word pattern being in the final block signature even though the word is not in the item . for example , if the signature for the word `` hard '' is 1000 0111 0010 0000 , it incorrectly matches the block signature in figure 4.13 (false hit) . in a study by faloutous and christodoulakis (faloutous-87) it was shown that if compression is applied to the final data-structure , the optimum number of bits per word is one . this then takes on the appearance of a binary coded vector for each item , where each position in the vector represents the existence of a word in the item . this approach requires the maximum code length but ensures that there are not any false hits unless two words hash to the same value . search of the signature matrix requires o (n) search-time . to reduce the search-time the signature matrix is partitioned horizontally . one of the earliest techniques hashes the block signature to a specific slot . if a query has less than the number of words in a block it maps to a number of possible slots rather than just one . the number of slots decreases exponentially as the number of terms increases (gustafson-71) . another approach maps the signatures into an index-sequential file , where , for example , the first un '' bits of the signature is used as the index to the block of signatures that will be compared sequentially to the query (lee-89) . other techniques are two level signatures (sacks-davis-83 , sacks-davis-88) and use of b-tree structures with similar signatures clustered at leaf nodes (deppisch86) . another implementation-approach takes advantage of the fact that searches are performed on the columns of the signature matrix , ignoring those columns that are not indicated by hashing of any of the search-terms . thus the signature matrix may be stored in column order versus row order (faioutsos-88 , lin-88 , roberts-79) , called vertical-partitioning . this is in effect storing the signature matrix using an inverted-file structure . the major overhead comes from updates , since new ul `` s have to be added to each inverted column representing a signature in the new item . signature-files provide a practical solution for storing and locating information in a number of different situations . faloutsos summarizes the environments that signature-files have been applied as medium size databases , databases with low frequency of terms , worm devices , parallel-processing machines , and distributed-environments (faloutsos-92) .