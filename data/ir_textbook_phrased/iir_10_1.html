basic xml concepts figure 10.1 : an xml-document . xml element tag xml attributes 10.1 figure 10.2 : the xml-document in figure 10.1 as a simplified dom object . figure 10.2 shows figure 10.1 as a tree . the leaf nodes of the tree consist of text , e.g. , shakespeare , macbeth , and macbeth 's castle . the tree 's internal-nodes encode either the structure of the document (title , act , and scene) or metadata functions (author) . the standard for accessing and processing xml-documents is the xml-document object-model or dom . the dom represents elements , attributes and text within elements as nodes in a tree . figure 10.2 is a simplified dom representation of the xml-document in figure 10.1 . with a dom-api , we can process an xml-document by starting at the root element and then descending down the tree from parents to children . xpath is a standard for enumerating paths in an xml-document collection . we will also refer to paths as xml contexts or simply contexts in this chapter . only a small subset of xpath is needed for our purposes . the xpath expression node selects all nodes of that name . successive elements of a path are separated by slashes , so act/scene selects all scene elements whose parent is an act element . double slashes indicate that an arbitrary number of elements can intervene on a path : play / / scene selects all scene elements occurring in a play element . in figure 10.2 this set consists of a single scene element , which is accessible via the path play , act , scene from the top . an initial slash starts the path at the root element . / play/title selects the play 's title in figure 10.1 , / play / / title selects a set with two members (the play 's title and the scene 's title) , and / scene/title selects no elements . for notational convenience , we allow the final element of a path to be a vocabulary term and separate it from the element path by the symbol # , even though this does not conform to the xpath standard . for example , title # `` macbeth '' selects all titles containing the term macbeth . we also need the concept of schema in this chapter . a schema puts constraints on the structure of allowable xml-documents for a particular application . a schema for shakespeare 's plays may stipulate that scenes can only occur as children of acts and that only acts and scenes have the number attribute . two standards for schemas for xml-documents are xml-dtd (document-type-definition) and xml-schema . users can only write structured-queries for an xml-retrieval system if they have some minimal knowledge about the schema of the collection . figure 10.3 : an xml-query in nexi format and its partial representation as a tree . a common format for xml-queries is nexi (narrowed extended xpath i) . we give an example in figure 10.3 . we display the query on four lines for typographical convenience , but it is intended to be read as one unit without line breaks . in particular , / / section is embedded under / / article . the query in figure 10.3 specifies a search for sections about the summer holidays that are part of articles from 2001 or 2002 . as in xpath double slashes indicate that an arbitrary number of elements can intervene on a path . the dot in a-clause in square brackets refers to the element the clause modifies . the clause [. / / yr = 2001 or . / / yr = 2002] modifies / / article . thus , the dot refers to / / article in this case . similarly , the dot in [about (. , summer holidays)] refers to the section that the clause modifies . the two yr conditions are relational attribute constraints . only articles whose yr attribute is 2001 or 2002 (or that contain an element whose yr attribute is 2001 or 2002) are to be considered . the about clause is a ranking constraint : sections that occur in the right type of article are to be ranked according to how relevant they are to the topic summer holidays . figure 10.4 : tree-representation of xml-documents and queries . we usually handle relational attribute constraints by prefiltering or postfiltering : we simply exclude all elements from the result-set that do not meet the relational attribute constraints . in this chapter , we will not address how to do this efficiently and instead focus on the core information-retrieval problem in xml-retrieval , namely how to rank documents according to the relevance-criteria expressed in the about conditions of the nexi query . if we discard relational attributes , we can represent documents as trees with only one type of node : element nodes . in other words , we remove all attribute nodes from the xml-document , such as the number attribute in figure 10.1 . figure 10.4 shows a subtree of the document in figure 10.1 as an element-node tree (labeled) . we can represent queries as trees in the same way . this is a query-by-example approach to query-language design because users pose queries by creating objects that satisfy the same formal-description as documents . in figure 10.4 , is a search for books whose titles score highly for the keywords julius caesar . is a search for books whose author elements score highly for julius caesar and whose title elements score highly for gallic war .