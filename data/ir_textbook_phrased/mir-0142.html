8.4 boolean-queries we now cover set manipulation algorithms . these algorithms are used when operating on sets of results , which is the case in boolean-queries . boolean-queries are described in chapter 4 , where the concept of query-syntax tree is defined . once the leaves of the query-syntax tree are solved (using the algorithms to find the documents containing the basic queries given) , the relevant documents must be worked on by composition-operators . normally the search proceeds in three phases : the first phase determines which documents classify , the second determines the relevance of the classifying documents so as to present them appropriately to the user , and the final phase retrieves the exact positions of the matches to highlight them in those documents that the user actually wants to see . this scheme avoids doing unnecessary work on documents which will not classify at last (first phase) , or will not be read at last (second phase) . however , some phases can be merged if doing the extra operations is not expensive . some phases may not be present at all in some scenarios . 208 indexing and searching and and lt ; Âªgt ; / \ / \ 146 or 146 23467 (b) and 246 237 or 2 4 or 2 4 or 3 4 or 4 3 4 3 4 7 6 figure 8.12 processing the internal-nodes of the query-syntax tree . in (a) full evaluation is used . in (b) we show lazy-evaluation in more detailonce the leaves of the query-syntax tree find the classifying sets of documents , these sets are further operated by the internal-nodes of the tree . it is possible to algebraically optimize the tree using identities such as a or (a and b) = a , for instance , or sharing common-subexpressions , but we do not cover this issue here . as all operations need to pair the same document in both their operands , it is good practice to keep the sets sorted , so that operations like intersection , union , etc. can proceed sequentially on both lists and also generate a sorted list . other representations for sets not consisting of the list of matching documents (such as bit-vectors) are also possible . under this scheme , it is possible to evaluate the syntax-tree in full or lazy form . in the full evaluation form , both operands are first completely obtained and then the complete result is generated . in lazy-evaluation , results are delivered only when required , and to obtain that result some data is recursively required to both operands . full evaluation allows some optimizations to be performed because the sizes of the results are known in advance (for instance , merging a very short list against a very long one can proceed by binary searching the elements of the short list in the long one) . lazy-evaluation , on the other hand , allows the application to control when to do the work of obtaining new results , instead of blocking it for a long time . hybrid schemes are possible , for example obtain all the leaves at once and then proceed in lazy form . this may be useful , for instance , to implement some optimizations or to ensure that all the accesses to the index are sequential (thus reducing disk-seek times) . figure 8.12 illustrates this . the complexity of solving these types of queries , apart from the cost of obtaining the results at the leaves , is normally linear in the total size of all the intermediate results . this is why this time may dominate the others , when there are huge intermediate results . this is more noticeable to the user when the final result is small . sequential-searching aldla | blrlal 209 | a b r a c a d abracadabra figure 8.13 brute-force search-algorithm for the pattern ` abracadabra . ' squared areas show the comparisons performed .