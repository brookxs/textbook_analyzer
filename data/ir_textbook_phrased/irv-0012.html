generating document representatives - conflation ultimately one would like to develop a text-processing-system which by menas of computable methods with the minimum of human-intervention will generate from the input-text (full text , abstract , or title) a document representative adequate for use in an automatic-retrieval system . this is a tall order and can only be partially met . the document representative i am aiming for is one consisting simply of a list of class-names , each name representing a class of words occurring in the total input-text . a document will be indexed by a name if one of its significant words occurs as a member of that class . such a system will usually consist of three parts : (1) removal of high-frequency words , (2) suffix-stripping , (3) detecting equivalent stems . the removal of high-frequency words , ` stop ' words or ` fluff ' words is one way of implementing luhn 's upper cut-off . this is normally done by comparing the input-text with a ` stop list ' of words which are to be removed . table 2.1 gives a portion of such a list , and demonstrates the kind of words that are involved . the advantages of the process are not only that non-significant words are removed and will therefore not interfere during retrieval , but also that the size of the total document file can be reduced by between 30 and 50 per cent . the second stage , suffix-stripping , is more complicated . a standard approach is to have a complete list of suffixes and to remove the longest possible one . table 2.2 lists some suffixes . unfortunately , context free removal leads to a significant error-rate . for example , we may well want ual removed from factual but not from equal . to avoid erroneously removing suffixes , context rules are devised so that a suffix will be removed only if the context is right . ` right ' may mean a number of things : (1) the length of remaining stem exceeds a given number ; the default is usually 2 ; (2) the stem-ending satisfies a certain condition , e.g. does not end with q . many words , which are equivalent in the above sense , map to one morphological-form by removing their suffixes . others , unluckily , though they are equivalent , do not . it is this latter category which requires special treatment . probably the simplest method of dealing with it is to construct a list of equivalent stem-endings . for two stems to be equivalent they must match except for their endings , which themselves must appear in the list as equivalent . for example , stems such as absorb - and absorpt - are conflated because there is an entry in the list defining b and pt as equivalent stem-endings if the preceding characters match . the assumption (in the context of ir) is that if two words have the same underlying stem then they refer to the same concept and should be indexed as such . this is obviously an over-simplification since words with the same stem , such as neutron and neutralise , sometimes need to be distinguished . even words which are essentially equivalent may mean different things in different contexts . since there is no cheap way of making these fine distinctions we put up with a certain proportion of errors and assume (correctly) that they will not degrade retrieval-effectiveness too much . it is inevitable that a processing system such as this will produce errors . fortunately experiments have shown that the error-rate tends to be of the order of 5 per cent (andrews [9]) . lovins [10 , 11] using a slightly different approach to stemming also quotes errors of the same order of magnitude . my description of the three stages has been deliberately undetailed , only the underlying mechanism has been explained . an excellent description of a conflation algorithm , based on lovins ' paper [10] may be found in andrews [9] , where considerable thought is given to implementation efficiency . surprisingly , this kind of algorithm is not core limited but limited instead by its processing-time . the final output from a conflation algorithm is a set of classes , one for each stem detected . a class-name is assigned to a document if-and-only-if one of its members occurs as a significant word in the text of the document . a document representative then becomes a list of class-names . these are often referred to as the documents index-terms or keywords . queries are of course treated in the same way . in an experimental situation they can be processed at the same time as the documents . in an operational situation , the text-processing-system needs to be applied to the query at the time that it is submitted to the retrieval-system .