basic terminology given a set of ` attributes ' a and a set of ` values ' v , then a record r is a subset of the cartesian-product a x v in which each attribute has one and only one value . thus r is a set of ordered pairs of the form (an attribute , its value) . for example , the record for a document which has been processed by an automatic-content-analysis algorithm would be r = {(k1 , x1) , (k2 , x2) , ... (km , xm)} the ki 's are keywords functioning as attributes and the value xi can be thought of as a numerical weight . frequently documents are simply characterised by the absence or presence of keywords , in which case we write r = {kt1 , kt2 , ... , kti} where kti is present if xti = 1 and is absent otherwise . records are collected into logical-units called files . they enable one to refer to a set of records by name , the file name . the records within a file are often organised according to relationships between the records . this logical organisation has become known as a file-structure (or data-structure) . it is difficult in describing file-structures to keep the logical features separate from the physical ones . the latter are characteristics forced upon us by the recording media (e.g. tape , disk) . some features can be defined abstractly (with little gain) but are more easily understood when illustrated concretely . one such feature is a field . in any implementation of a record , the attribute values are usually positional , that is the identity of an attribute is given by the position of its attribute-value within the record . therefore the data within a record is registered sequentially and has a definite beginning and end . the record is said to be divided into fields and the nth field carries the nth attribute-value . pictorially we have an example of a record with associated fields in figure 4.1 . the fields are not necessarily constant in length . to find the value of the attribute k4 , we first find the address of the record r (which is actually the address of the start of the record) and read the data in the 4th field . in the same picture i have also shown some fields labelled pi . they are addresses of other records , and are commonly called pointers . now we have extended the definition of a record to a set of attribute-value-pairs and pointers . each pointer is usually associated with a particular attribute-value-pair . for example , (see figure 4.2) pointers could be used to link all records for which the value x1 (of attribute k1) is a , similarly for x2 equal to b , etc. . to indicate that a record is the last record pointed to in a list of records we use the null pointer [[logicaland]] . the pointer associated with attribute k in record r will be called a k-pointer . an attribute (keyword) that is used in this way to organise a file is called a key . the unify the discussion of file-structures we need some further concepts . following hsiao and harary again , we define a list l of records with respect to a keyword k , or more briefly a k-list as a set of records containing k such that : (1) the k-pointers are distinct ; (2) each non-null k-pointer in l gives the address of a record within l ; (3) there is a unique record in l not pointed to by any record containing k ; it is called the beginning of the list ; and (4) there is a unique record in l containing the null k-pointer ; it is the end of the list . (hsiao and harary state condition (2) slightly differently so that no two k-lists have a record in common ; this only appears to complicate things .) from our previous example : k1-list : r1 , r2 , r5 k2-list : r2 , r4 k4-list : r1 , r2 , r3 finally , we need the definition of a directory of a file . let f be a file whose records contain just m different keywords k1 , k2 , ... , km . let ni be the number of records containing the keyword ki , and hi be the number of ki-lists in f. furthermore , we denote by aij the beginning address of the jth ki-list . then the directory is the set of sequences (ki , ni , hi , ai1 , ai2 , ... aihi) i = 1 , 2 , ... m we are now in a position to give a unified treatment of sequential-files , inverted-files , index-sequential files and multi-list files .