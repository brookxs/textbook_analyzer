7.4.5 inverted-file compression as already discussed , an inverted-file is typically composed of (a) a vector containing all the distinct words in the text-collection (which is called the vocabulary) and (b) for each word in the vocabulary , a list of all documents in which that word occurs . inverted-files are widely used to index large text files . the size of an inverted-file can be reduced by compressing the inverted-lists . because the list of document numbers within the inverted list is in ascending order , it can also be considered as a sequence of gaps between document numbers . since processing is usually done sequentially starting from the beginning of the list , the original document numbers can always be recomputed through sums of the gaps . by observing that these gaps are small for frequent words and large for infrequent words , compression can be obtained by encoding small values with shorter codes . one possible coding-scheme for this case is the unary cade , in which an integer x is coded as (x - 1) one bits followed by a zero bit , so the code for the integer 3 is 110 . the second column of table 7.1 shows unary codes for integers between 1 and 10 . elias [235] presented two other variable-length-coding schemes for integers . one is elias - ^ code , which represents the number j by a concatenation of two text-compression 185 gap x unary elias-7 elias-lt ; 5 golomb 6 = 3 1 0 0 0 00 2 10 100 1000 010 3 110 101 1001 oil 4 1110 11000 10100 100 5 11110 11001 10101 1010 6 111110 11010 10110 1011 7 1111110 11011 10111 1100 8 11111110 1110000 11000000 11010 9 111111110 1110001 11000001 11011 10 1111111110 1110010 11000010 11100 table 7.1 example codes for integers . parts : (1) a unary code for 1 + llogxj and (2) a code of [log rej bits that represents the value of x - 2llos * j in binary . for x = 5 , we have that 1 - h [logxj = 3 and that x - 2llosxj = 1 . thus , the elias-7 code for x = 5 is generated by combining the unary code for 3 (code 110) with the 2-bits binary number for 1 (code 01) which yields the codeword 11001 . other examples of elias-7 codes are shown in table 7.1 . the other coding-scheme introduced by elias is the elias-5 code , which represents the prefix indicating the number of binary bits by the elias-7 code rather than the unary code . for x = 5 , the first part is then 101 instead of 110 . thus , the elias-5 codeword for x = 5 is 10101 . in general , the elias-5 code for an arbitrary integer x requires 1 - f 2 [loglog2xj + [log xj bits . table 7.1 shows other examples of elias ~ lt ; $ codes . in general , for small values of x the elias-7 codes are shorter than the elias - # codes . however , in the limit , as x becomes large , the situation is reversed . golomb [307] presented another run-length coding method for positive integers . the golomb code is very effective when the probability distribution is geometric . with inverted-files , the likelihood of a gap being of size x can be computed as the probability of having x - 1 non-occurrences (within consecutively numbered documents) of that particular word followed by one occurrence . if a word occurs within a document with a probability p , the probability of a gap of size x is then pr [x \ = {l-pf ~ lp which is the geometric-distribution . in this case , the model is parameterized and makes use of the actual density of pointers in the inverted-file . let n be the number of documents in the system and v be the size of the vocabulary . then , the probability p that any randomly selected document contains any randomly 186 text operations chosen term can be estimated as number of pointers p == n x v where the number of pointers represent the ` size ' of the index . the golomb method works as follows . for some parameter b , a gap x gt ; 0 is coded as q - h 1 in unary , where q = [(x ó 1) / 6j , followed by r = (x ó 1) ó q x b coded in binary , requiring either [logb] or (`` log b] bits . that is , if r lt ; 2 llos # gt ; j ó i then the number coded in binary requires [logfrj bits , otherwise it requires flog b] bits where the first bit is 1 and the remaining bits assume the value r ó 2 ' - los ^ ~ 1 coded in [logb \ binary digits . for example , with b = 3 there are three possible remainders , and those are coded as 0 , 10 , and 11 , for r = 0 , r = 1 , and r = 2 , respectively . similarly , for b = 5 there are five possible remainders r , 0 through 4 , and these are assigned codes 00 , 01 , 100 , 101 , and 110 . then , if the value x = 9 is to be coded relative to 6 = 3 , calculation yields q = 2 and r == 2 , because 9-1 = 2 x 3 + 2 . thus , the encoding is 110 followed by 11 . relative to b = 5 , the values calculated are q = 1 and r = 1 , resulting in a code of 10 followed by 101 . to operate with the golomb compression-method , it is first necessary to establish the parameter b for each term . for gap compression , an appropriate value is b ´ 0.69 (ar / / t) ^ where n is the total number of documents and ft is the number of documents that contain term t. witten , moffat and bell [825] present a detailed study of different text-collections . for all of their practical work on compression of inverted-lists , they use golomb code for the list of gaps . in this case golomb code gives better compression than either elias-7 or elias - # . however , it has the disadvantage of requiring two passes to be generated , since it requires knowledge of ft , the number of documents containing term t. moffat and bell [572] show that the index for the 2 gigabytes trec-3 collection , which contains 162,187,989 pointers and 894,406 distinct terms , when coded with golomb code , occupies 132 megabytes . considering the average number of bits per pointer , they obtained 5.73 , 6.19 , and 6.43 using golomb , elias - $ , and elias-7 , respectively .