4.4.3 hierarchical-structure an intermediate structuring model which lies between fixed structure and hypertext is the hierarchical-structure . this model represents a recursive decomposition of the text and is a natural model for many text-collections (e.g. , books , articles , legal documents , structured programs , etc.) . figure 4.3 shows an example of such a hierarchical-structure . the simplification from hypertext to a hierarchy allows the adoption of faster algorithms to solve queries . as a general rule , the more powerful the model , the less efficiently it can be implemented . our aim in this section is to analyze and discuss the different approaches presented by the hierarchical-models . we first present a selection of the most representative models and then discuss the main subjects of this area . chapter 4 (t chapter ^) 4.1 introduction we cover in this chapter the different kinds of . . (^ section ^) c section '') 4.4 structural queries ; c ^ tltle ^) qigurej) j , introduction we cover ... structural ... ^ figure section title `` structural '' figure 4.3 an example of a hierarchical-structure : the page of a book , its schematic view , and a parsed query to retrieve the figure . 110 query-languages a sample of hierarchical-models pat expressions these are built on the same index as the text-index , i.e. there is no special separate index on the structure . the structure is assumed to be marked in the text by tags (as in html) , and therefore is defined in terms of initial and final tags . this allows a dynamic scheme where the structure of interest is not fixed but can be determined at query time . for instance , since tags need not to be especially designed as normal tags , one can define that the end-of-lines are the marks in order to define a structure on lines . this also allows for a very efficient-implementation and no additional space-overhead for the structure . each pair of initial and final tags defines a region , which is a set of contiguous text areas . externally computed regions are also supported . however , the areas of a region can not nest or overlap , which is quite restrictive . there is no restriction on areas of different regions . apart from text-searching operations , it is possible to select areas containing (or not) other areas , contained (or not) in other areas , or followed (or not) by other areas . a disadvantage is that the algebra mixes regions and sets of text positions which are incompatible and force complex conversion semantics . for instance , if the result of a query is going to generate overlapping areas (a fact that can not be determined beforehand) then the result is converted to positions . also , the dynamic definition of regions is flexible but requires the structure to be express-able using tags (also called ` markup ' , see chapter 6) , which for instance does not occur in some structured-programming languages . overlapped lists these can be seen as an evolution of pat expressions . the model allows for the areas of a region to overlap , but not to nest . this elegantly solves the problems of mixing regions and sets of positions . the model considers the use of an inverted list (see chapter 8) where not only the words but also the regions are indexed . apart from the operations of pat expressions , the model allows us to perform set union , and to combine regions . combination means selecting the minimal text areas which include any two areas taken from two regions . a ` followed by ' operator imposes the additional restriction that the first area must be before the second one . an kn words ' operator generates the region of all (overlapping) sequences of n words of the text (this is further used to retrieve elements close to each other) . if an operation produces a region with nested areas , only the minimal areas are selected . an example is shown in figure 2.11 . the implementation of this model can also be very efficient . it is not clear , however , whether overlapping is good or not for capturing the structural-properties that information has in practice . a new proposal allows the structure to be nested and overlapped , showing that more interesting operators can still be implemented . structural queries 111 lists of references these are an attempt to make the definition and querying of structured-text uniform , using a common language . the language goes beyond querying structured-text , so we restrict our attention to the subset in which we are interested . the structure-of-documents is fixed and hierarchical , which makes it impossible to have overlapping results . all possible regions are defined at indexing time . the answers delivered are more restrictive , since nesting is not allowed (only the top-level elements qualify) and all elements must be of the same type , e.g. only sections , or only paragraphs . in fact , there are also hypertext-links but these can not be queried (the model also has navigational features) . a static hierarchical-structure makes it possible to speak in terms of direct ancestry of nodes , a concept difficult to express when the structure is dynamic . the language allows for querying on ` path-expressions , ' which describe paths in the structure tree . answers to queries are seen as lists of ` references . ' a reference is a pointer to a region of the database . this integrates in an elegant way answers to queries and hypertext-links , since all are lists of references . proximal nodes this model tries to find a good compromise between expressiveness and efficiency . it does not define a specific language , but a model in which it is shown that a number of useful operators can be included achieving good efficiency . the structure is fixed and hierarchical . however , many independent structures can be defined on the same text , each one being a strict hierarchy but allowing overlaps between areas of different hierarchies . an example is shown in figure 2.12 . a query can relate different hierarchies , but returns a subset of the nodes of one hierarchy only (i.e. , nested elements are allowed in the answers , but no overlaps) . text-matching queries are modeled as returning nodes from a special ` text hierarchy . ' the model specifies a fully compositional language where the leaves of the query-syntax tree are formed by basic queries on contents or names of structural elements (e.g. , all chapters) . the internal-nodes combine results . for efficiency , the operations defined at the internal-nodes must be implementable looking at the identity and text areas of the operands , and must relate nodes which are close in the text . it has been shown that many useful operators satisfy this restriction : selecting elements that (directly or transitively) include or are included in others ; that are included at a given position (e.g. , the third paragraph of each chapter) ; that are shortly before or after others ; set manipulation ; and many powerful variations . operations on content elements deliver a set of regions with no nesting , and those results can be fully integrated into any query . this ability to integrate the text into the model is very useful . on the other hand , some queries requiring non-proximal operations are not allowed , for instance semijoins . an example of a semijoin is ` give me the titles of all the chapters referenced in this chapter / 112 query-languages tree-matching this model relies on a single primitive : tree-inclusion , whose main idea is as follows . interpreting the structure both of the text-database and of the query (which is defined as a pattern on the structure) as trees , determine an embedding of the query into the database which respects the hierarchical-relationships between nodes of the query . two variants are studied . ordered inclusion forces the embedding to respect the left-to-right relations among siblings in the query , while unordered inclusion does not . the leaves of the query can be not only structural elements but also text patterns , meaning that the ancestor of the leaf must contain that pattern . simple queries return the roots of the matches . the language is enriched by prolog-like variables , which can be used to express requirements on equality between parts of the matched substructure and to retrieve another part of the match , not only the root . logical variables are also used for union and intersection of queries , as well as to emulate tuples and join capabilities . although the language is set oriented , the algorithms work by sequentially obtaining each match . the use of logical variables and unordered inclusion makes the search-problem intractable (np-hard in many cases) . even the good cases have an inefficient solution in practice . discussion a survey of the main hierarchical-models raises a number of interesting issues , most of them largely unresolved up to now . some of them are listed below . static or dynamic-structure as seen , in a static structure there are one or more explicit hierarchies (which can be queried , e.g. , by ancestry) , while in a dynamic-structure there is not really a hierarchy , but the required elements are built on-the-fly . a dynamic-structure is implemented over a normal text-index , while a static one may or may not be . a static structure is independent of the text-markup , while a dynamic one is more flexible for building arbitrary structures . restrictions on the structure the text or the answers may have restrictions about nesting and/or overlapping . in some cases these restrictions exist for efficiency reasons . in other cases , the query-language is restricted to avoid restricting the structure . this choice is largely dependent on the needs of each application . integration with text in many structured models , the text-content is merely seen as a secondary source of information which is used only to restrict the matches of structural elements . in classic ir-models , on the other side , information on the structure is the secondaxv element which is used onlv to restrict text matches . for an effective query protocols 113 integration of queries on text-content with queries on text-structure , the query-language must provide for full expressiveness of both types of queries and for effective means of combining them . query-language typical queries on structure allow the selection of areas that contain (or not) other areas , that are contained (or not) in other areas , that follow (or are followed by) other areas , that are close to other areas , and set manipulation . many of them are implemented in most models , although each model has unique features . some kind of standardization , expressiveness taxonomy , or formal categorization would be highly desirable but does not exist yet .