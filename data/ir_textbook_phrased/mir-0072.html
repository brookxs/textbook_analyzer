4.2.3 boolean-queries the oldest (and still heavily used) form of combining keyword-queries is to use boolean-operators . a boolean-query has a syntax composed of atoms (i.e. , basic queries) that retrieve documents , and of boolean-operators which work on their operands (which are sets of documents) and deliver sets of documents . since this scheme is in general compositional (i.e. , operators can be composed over the results of other operators) , a query-syntax tree is naturally defined , where the leaves correspond to the basic queries and the internal-nodes to the operators . the query-syntax tree operates on an algebra over sets of documents (and the final answer of the query is also a set of documents) . this is much as , for instance , the syntax-trees of arithmetic-expressions where the numbers and variables are the leaves and the operations form the internal-nodes . figure 4.1 shows an example . the operators most commonly used , given two basic queries or boolean keyword-based querying 103 subexpressions t \ and e2 , are : © or the query (ei or 62) selects all documents which satisfy ei or 62-duplicates are eliminated . æ and the query (ei and e2) selects all documents which satisfy both e \ and e2æ but the query (ei but e2) selects all documents which satisfy e \ but not e2 . notice that classical boolean-logic uses a not operation , where (not e2) is valid whenever 62 is not . in this case all documents not satisfying e2 should be delivered , which may retrieve a huge amount of text and is probably not what the user wants . the but operator , instead , restricts the universe of retrievable elements to the result of e \ . \ besides selecting the appropriate documents , the ir-system may also sort the documents by some criterion , highlight the occurrences within the documents of the words mentioned in the query , and allow feedback by taking the answer set as a basis to reformulate the query . with classic boolean systems , no ranking of the retrieved documents is normally provided . a document either satisfies the boolean-query (in which case it is retrieved) or it does not (in which case it is not retrieved) . this is quite a limitation because it does not allow for partial-matching between a document and a user-query . to overcome this limitation , the condition for retrieval must be relaxed . for instance , a document which partially satisfies an and condition might be retrieved . in fact , it is widely accepted that users not trained in mathematics find the meaning of boolean-operators difficult to grasp . with this problem in mind , a lfuzzy boolean1 set of operators has been proposed . the idea is that the meaning of and and or can be relaxed , such that instead of forcing an element to appear in all the operands (and) or at least in one of the operands (or) , they retrieve elements appearing in some operands (the and may require it to appear in more operands than the or) . moreover , the documents are ranked higher when they have a larger number of elements in common with the query (see chapter 2) .