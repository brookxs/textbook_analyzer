search structures for dictionaries given an inverted-index and a query , our first task is to determine whether each query-term exists in the vocabulary and if so , identify the pointer to the corresponding postings . this vocabulary lookup operation uses a classical data-structure called the dictionary and has two broad classes of solutions : hashing , and search-trees . in the literature of data-structures , the entries in the vocabulary (in our case , terms) are often referred to as keys . the choice of solution (hashing , or search-trees) is governed by a number of questions : (1) how many keys are we likely to have ? (2) is the number likely to remain static , or change a lot - and in the case of changes , are we likely to only have new keys inserted , or to also have some keys in the dictionary be deleted ? (3) what are the relative frequencies with which various keys will be accessed ? hashing has been used for dictionary-lookup in some search-engines . each vocabulary term (key) is hashed into an integer over a large enough space that hash collisions are unlikely ; collisions if any are resolved by auxiliary structures that can demand care to maintain . at query time , we hash each query-term separately and following a pointer to the corresponding postings , taking into account any logic for resolving hash collisions . there is no easy way to find minor variants of a query-term (such as the accented and non-accented versions of a word like resume) , since these could be hashed to very different integers . in particular , we can not seek (for instance) all terms beginning with the prefix automat , an operation that we will require below in section 3.2 . finally , in a setting (such as the-web) where the size of the vocabulary keeps growing , a hash-function designed for current needs may not suffice in a few years ' time . a binary-search tree.in this example the branch at the root partitions vocabulary terms into two subtrees , those whose first letter is between a and m , and the rest . search-trees overcome many of these issues - for instance , they permit us to enumerate all vocabulary terms beginning with automat . the best-known search-tree is the binary tree , in which each internal node has two children . the search for a term begins at the root of the tree . each internal node (including the root) represents a binary test , based on whose outcome the search proceeds to one of the two sub-trees below that node . figure 3.1 gives an example of a binary-search-tree used for a dictionary . efficient search (with a number of comparisons that is) hinges on the tree being balanced : the numbers of terms under the two sub-trees of any node are either equal or differ by one . the principal issue here is that of rebalancing : as terms are inserted into or deleted from the binary search-tree , it needs to be rebalanced so that the balance property is maintained . to mitigate rebalancing , one approach is to allow the number of sub-trees under an internal node to vary in a fixed interval . a search-tree commonly used for a dictionary is the b-tree - a search-tree in which every internal node has a number of children in the interval , where and are appropriate positive integers ; figure 3.2 shows an example with and . each branch under an internal node again represents a test for a range of character sequences , as in the binary-tree example of figure 3.1 . a b-tree may be viewed as `` collapsing '' multiple levels of the binary tree into one ; this is especially advantageous when some of the dictionary is disk-resident , in which case this collapsing serves the function of pre-fetching imminent binary tests . in such cases , the integers and are determined by the sizes of disk blocks . section 3.5 contains pointers to further background on search-trees and b-trees . a b-tree . in this example every internal node has between 2 and 4 children . it should be noted that unlike hashing , search-trees demand that the characters used in the document-collection have a prescribed ordering ; for instance , the 26 letters of the english alphabet are always listed in the specific order a through z . some asian-languages such as chinese do not always have a unique ordering , although by now all languages (including chinese and japanese) have adopted a standard ordering system for their character-sets .