8.5.5 suffix automaton the backward dawg matching (bdm) algorithm is based on a suffix automaton . a suffix automaton on a pattern p is an automaton that recognizes all the suffixes of p . the non-deterministic version of this automaton has a very regular-structure and is shown in figure 8.18 . the bdlvf algorithm converts this automaton to deterministic . the size and construction time of this automaton is o (m) . this is basically the preprocessing effort of the algorithm . each path from the initial node to any internal 214 indexing and searching ~ ~ ** '' (r) -1 ----------- t ---------- t ----------- 1 ----------- 1 ----------- 1 ----------- t ----------- 1 ----------- 1 ----------- 1 ------------ 1 ------------ * figure 8.18 a non-deterministic suffix automaton . dashed lines represent e-transitions (i.e. , they occur without consuming any input) . i is the initial-state of the automaton . x | x xx figure 8-19 the bdm algorithm for the pattern ` abracadabra . ' the rectangles represent elements compared to the text window . the xs show the positions where a pattern prefix was recognized . node represents a substring of the pattern . the final nodes represent pattern suffixes . to search a pattern p , the suffix automaton of pr (the reversed pattern) is built . the algorithm searches backwards inside the text window for a substring of the pattern p using the suffix automaton . each time a terminal state is reached before hitting the beginning of the window , the position inside the window is remembered . this corresponds to finding a prefix of the pattern equal to a suffix of the window (since the reverse suffixes of pr are the prefixes of p) . the last prefix recognized backwards is the longest prefix of p in the window . a match is found if the complete window is read , while the check is abandoned when there is no transition to follow in the automaton . in either case , the window is shifted to align with the longest prefix recognized . see figure 8.19 . this algorithm is o (rnn) time in the worst-case and 0 {n log (m) / m) on average . there exists also a multipattern version of this algorithm called multibdm , which is the fastest for many patterns or very long patterns . bdm rarely beats the best bm algorithms . however , a recent bit-parallel implementation called bndn1 improves over bm in a wide range of cases . this algorithm simulates the non-deterministic suffix automaton using bit-parallelism . the algorithm supports some extended patterns and other applications mentioned in shift-or , while keeping more efficient than shift-or .