7.5 weighted searches of boolean systems the two major approaches to generating queries are boolean and natural-language . natural-language queries are easily represented within statistical-models and are usable by the similarity-measures discussed . issues arise when boolean-queries are associated with weighted index systems . some of the issues are associated with how the logic (and , or , not) operators function with weighted values and how weights are associated with the query terms . if the operators are interpreted in their normal interpretation , thay act too restrictive or too general (i.e. , and and or operators respectively) . salton , fox and wu showed that using the strict definition of the operators will suboptimize the retrieval expected by the user (salton-83a) . closely related to the strict definition problem is the lack of ranking that is missing from a pure boolean process . some of the early work addressing this problem recognized the fuzziness associated with mixing boolean and weighted systems (brookstein-78 , brookstein-80) to integrate the boolean and weighted systems model , fox and sharat proposed a fuzzy-set approach (fox-86) . fuzzy-sets introduce the concept of degree of membership to a set (zadeh-65) . the degree of membership for and and or operations are defined as : deganb = min (dega , degb) degaub = max (dega , degb) where a and b are terms in an item . deg is the degree of membership . the mixed min and max (mmm) model considers the similarity between query and document to be a linear combination of the minimum and maximum item weights . fox proposed the following similarity formula : sim (queryor , doc) = c0r , * max (docl , , dgc2 ... , docn) + c0r2 * min (d0ci , doc2 , ... , docn) s!m (queryand , doc) = cand1 * min (doc , , doc2 , ... , docn) + cand2 * max (docl , , doc2 , ... , docn) where cqri and c0r2 are weighting coefficients for the or operation and candi and cakd2 are the weighting coefficients for the and-operation . lee and fox found in their experiments that the best performance comes when candi is between 0.5 to 0.8 and cori is greater than 0.2 . user-search techniques 187 the mmm technique was expanded by paice (paice-84) considering all item weights versus the maximum/minimum approach . the similarity-measure is calculated as : sim (query doc) = where the d ^ s are inspected in ascending order for and queries and descending order for or queries . the r terms are weighting coefficients . lee and fox showed that the best values for r are 1.0 for and queries and 0.7 for or queries (lee-88) . this technique requires more computation since the values need to be stored in ascending or descending order and thus must be sorted . an alternative approach is using the p-norm-model which allows terms within the query to have weights in addition to the terms in the items . similar to the cosine-similarity technique , it considers the membership values (daj , ... , dan) to be coordinates in an `` n '' dimensional space . for an or query , the origin (all values equal zero) is the worst possibility . for an and query the ideal-point is the unit vector where all the d ; values equal 1 . thus the best ranked documents will have maximum distance from the origin in an or query and minimal distance from the unit vector point . the generalized queries are : qor = (a , t , a0 or (a2 , a2) or ... or (an , an) qand = (a , , , a ,) and (a2 , a2) and ... and (an , an) the operators (and and or) will have a strictness value assigned that varies from 1 to infinity where infinity is the strict definition of the boolean operator . the a , values are the query-term weights . if we assign the strictness value to a parameter labeled `` s '' then the similarity formulas between queries and items are : sds) / (af + a \ + ï ï ï + as sim (qor , doc) = $] (a?dsal + ï ï ï + asndsan) / (af + a \ + ï ï ï + asn sim (qand , doc) = i - sj sim (qnot , doc) = i - sim (q , doc) another approach suggested by salton provides additional insight into the issues of merging the boolean-queries and weighted query terms under the assumption that there are no weights available in the indexes (saiton-83) . the objective is to perform the normal boolean-operations and then refine the results using weighting techniques . the following procedure is a modification to his 188 chapter 7 approach for defining search-results . the normal boolean-operations produce the following results : `` a or b '' retrieves those items that contain the term a or the term b or both `` a and b '' retrieves those items that contain both terms a and b `` a not b '' retrieves those items that contain term a and not contain term b . if weights are then assigned to the terms between the values 0.0 to 1.0 , they may be interpreted as the significance that users are placing on each term . the value 1.0 is assumed to be the strict interpretation of a boolean-query . the value 0.0 is interpreted to mean that the user places little value on the term . under these assumptions , a term assigned a value of 0.0 should have no effect on the retrieved set . thus `` aj or bo '' should return the set of items that contain a as a term `` ai and bo '' will also return the set of items that contain term a `` aj not bo '' also return set a . this suggests that as the weight for term b goes from 0.0 to 1.0 the resultant set changes from the set of all items that contains term a to the set normally generated from the boolean-operation . the process can be visualized by use of the venn diagrams shown in figure 7.10 . under the strict interpretation `` a] or bj '' would include all items that are in all the areas in the venn-diagram . `` ai or bo '' would be only those items in a (i.e. , the whie and black dotted areas) which is everything except items in `` b not a '' (the grey area .) thus as the value of query-term b goes from 0.0 to 1.0 , items from `` b not a '' are proportionally added until at 1.0 all of the items will be added . similarly , under the strict interpretation `` aj and bj '' would include all of the items that are in the black dotted area . `` a , and bo '' will be all of the items in a as described above . thus , as the value of query-term b goes from 1.0 to 0.0 items will be proportionally added from `` a not b '' (white area) until at 0.0 all of the items will be added . finally , the strict interpretation of `` as not bt '' is grey area while `` ai not bo '' is all of a. thus as the value of b goes from 0.0 to 1.0 , items are proportionally added from `` a and b '' (black dotted area) until at 1.0 all of the items have been added . the final issue is the determination of which items are to be added or dropped in interpreting the weighted values . inspecting the items in the totally user-search techniques 189 figure 7.10 venn-diagram strict case (both terms having weight 1.0) and the case where the value is 0.0 there is a set of items that are in both solutions (invariant set) . in adding items they should be the items most similar to the set of items that does not change in either situation . in dropping items , they should be the items least similar to those that are in both situations . thus the algorithm follows the following steps : 1 . determine the items that are satisfied by applying strict interpretation of the boolean-functions 2 . determine the items that are part of the set that is invariant 3 . determine the centroid of the invariant set 4 . determine the number of items to be added or deleted by multiplying the term-weight times the number of items outside of the invariant set and rounding up to the nearest whole number 5 . determine the similarity between items outside of the invariant set and the centroid 6 . select the items to be included or removed from the final set figure 7.11 gives an example of solving a weighted boolean-query . query * ends up with a set containing all of the items that contain the term `` computer '' and two items from the set `` computer '' not `` program . '' the symbol \] stands for rounding up to the next integer . in query2 the final set 190 chapter 7 computer-program cost sale dl 0 4 0 8 d2 0 2 0 0 d3 4 0 2 4 d4 0 6 4 6 d5 0 4 6 4 d6 6 0 4 0 d7 0 0 0 0 r _) c 4 2 0 2 ql = query] = computer10 or program 333 q2 = query , = cost 75 and sale10 ql strict interpretation = (dl , d2 , d3 , d4 , d5 , d6 , d8) q2stnctmterpretat1on = qluivariant = (d8) q2invanant = (d3 , d4 , d5) qlopnonai = (dl , d2 , d3 , d4 , d5 , d6) thus f. 333 times 6 items] = 2 items q2optonai = (dl , d8) which means [(1 - .75) times 2 items] = 1 item figure 7.11 example of weighted boolean-query contains all of set `` cost '' and `` sale '' plus .25 of the set of `` sale '' not `` cost . '' using the simple similarity-measure : sim (item , , itemj) = i (term , , k) (termjgt ; k) leads to the following set of similarity values based upon the centroids : centroid (ql) = (d8) = (4 , 2 , 0 , 2) centroid (q2) = (d3 , d4 , d5) = 1/3 (4 +0 +0 , 0 +6 +4 , 2 +4 +6 , 4 +6 +4) sim (centroid0 , , d1) = (0 + 8 + 0 +16) = 24 sim (centroidoi , d2) - (0 + 4 + 0 + 0) = 4 sim (centroidqi , d3) = (16 + 0 + 0 + 8) = 24 sim (centroidq | 9d4) = (0 + 12 + 0 + 12) = 24 sim (centroidq , , d5) = (0 + 8 + 0 + 8) = 16 sim (centroid0i , d6) = (24 + 0 + 0 + 0) = 24 sim (centro!do : , dl) = 1/3 (0 + 40 + 0 + 112) = 1/3 (152) sim (centrgidq2 , d8) = 1/3 (16 + 20 +0 +28) = 1/3 (64) user-search techniques 191 for ql , two additional items are added to the invariant set (d8) u (dl , d3) , by choosing the lowest number items because of the tie at 24 , giving the answer of (dl , d3 , d8) . for q2 , one additional item is added to the invariant set (d3 , d4 , d5) u (dl) giving the answer (dl , d3 , d4 , d5) .