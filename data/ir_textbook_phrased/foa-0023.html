2.1 building useful tools the promise offered by chapter 1 is that many real-world-problems can be viewed as instances of the foa problem . the proof is to be found in concrete code - a relatively small technology base that will prove useful in a wide array of applicatons . in this chapter we will present a suite of software-tools that together build a search-engine for a wide variety of situations . source-code is provided so that these tools can be easily modified for applications of your own * we will work through two different examples of ir systems , in order to demonstrate how slight variations of the same basic code can handle both . compared to the broad generalities of chapter 1 , the technical details of this chapter will sound a very different tone . describing a complex algorithm requires the specification of many , sometimes tedious , details . to make the software executable on machines that are likely to be available to you , the details are provided for several operating environments . but the processor speeds , internal memory , and hard-disk sizes available on computers are changing dramatically each year , so many of the assumptions on which these routines are based will require constant reevaluation . we will develop the software-tools in three phases . the first phase will convert an arbitrary pile of textual objects into a well-defined corpus 40 finding out about of documents , each containing a string of terms to be indexed . the second phase involves building efficient data-structures to invert the index relation so that , rather than seeing all the words contained in a particular document , we can find all documents containing particular keywords . all of these efforts are in anticipation of the third and final phase , which matches queries against indices to retrieve those that are most similar . these three major phases are central to building any search-engine . this chapter will be most concerned with the first two phases , which together extract lexical-features . our goal will be the extraction of a set-of-features worthy of subsequent analysis . as in any cognitive-science , the specification of an appropriate level of analysis - whether it is the resolution and depth of an image , the subphonemes of continuous-speech , the speech-acts of language , or something else - the specification of this atomic feature set is the first important step . this will involve a great deal of work , much of it unpleasant except to those who enjoy designing efficient-algorithms and data-structures (some of us actually do enjoy this ! :-rrb- . the promise is that we will , as a consequence of good software-design , develop useful tools that allow us to spend the rest of our time exploring interesting features of language .