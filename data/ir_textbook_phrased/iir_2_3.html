faster postings list-intersection via skip pointers in the remainder of this chapter , we will discuss extensions to postings list data-structures and ways to increase the efficiency of using postings lists . recall the basic postings list-intersection operation from section 1.3 (page) : we walk through the two postings lists simultaneously , in time linear in the total number of postings entries . if the list lengths are and , the intersection takes operations . can we do better than this ? that is , empirically , can we usually process postings list-intersection in sublinear-time ? we can , if the index is n't changing too fast . one way to do this is to use a skip-list by augmenting postings lists with skip pointers (at indexing time) , as shown in figure 2.9 . skip pointers are effectively shortcuts that allow us to avoid processing parts of the postings list that will not figure in the search-results . the two questions are then where to place skip pointers and how to do efficient merging using skip pointers . postings lists with skip pointers.the postings intersection can use a skip pointer when the end point is still less than the item on the other list . figure 2.10 : postings lists-intersection with skip pointers . consider first efficient merging , with figure 2.9 as an example . suppose we 've stepped through the lists in the figure until we have matched on each list and moved it to the results list . we advance both pointers , giving us on the upper list and on the lower list . the smallest item is then the element on the top list . rather than simply advancing the upper pointer , we first check the skip-list pointer and note that 28 is also less than 41 . hence we can follow the skip-list pointer , and then we advance the upper pointer to . we thus avoid stepping to and on the upper list . a number of variant versions of postings list-intersection with skip pointers is possible depending on when exactly you check the skip pointer . one version is shown in figure 2.10 . skip pointers will only be available for the original postings lists . for an intermediate-result in a complex-query , the call will always return false . finally , note that the presence of skip pointers only helps for and queries , not for or queries . where do we place skips ? there is a tradeoff . more skips means shorter skip spans , and that we are more likely to skip . but it also means lots of comparisons to skip pointers , and lots of space storing skip pointers . fewer skips means few pointer comparisons , but then long skip spans which means that there will be fewer opportunities to skip . a simple heuristic for placing skips , which has been found to work well in practice , is that for a postings list of length , use evenly-spaced skip pointers . this heuristic can be improved upon ; it ignores any details of the distribution of query terms . building effective skip pointers is easy if an index is relatively static ; it is harder if a postings list keeps changing because of updates . a malicious deletion strategy can render skip-lists ineffective . choosing the optimal encoding for an inverted-index is an ever-changing game for the system builder , because it is strongly dependent on underlying computer technologies and their relative speeds and sizes . traditionally , cpus were slow , and so highly compressed techniques were not optimal . now cpus are fast and disk is slow , so reducing disk postings list size dominates . however , if you 're running a search-engine with everything in memory then the equation changes again . we discuss the impact of hardware-parameters on index-construction time in section 4.1 (page) and the impact of index-size on system speed in chapter 5 . exercises . why are skip pointers not useful for queries of the form or ? we have a two-word query . for one term the postings list consists of the following 16 entries : [4,6,10,12,14,16,18,20,22,32,47,81,120,122,157,180] and for the other it is the one entry postings list : [47] . work out how many comparisons would be done to intersect the two postings lists with the following two strategies . briefly justify your answers : using standard postings lists using postings lists stored with skip pointers , with a skip length of , as suggested in section 2.3 . consider a postings intersection between this postings list , with skip pointers : xunit = 0.6 cm , arcangle = 30 and the following intermediate-result postings list (which hence has no skip pointers) : 3 5 89 95 97 99 100 101 trace through the postings intersection algorithm in figure 2.10 (page) . how often is a skip pointer followed (i.e. , is advanced to) ? how many postings comparisons will be made by this algorithm while intersecting the two lists ? how many postings comparisons would be made if the postings lists are intersected without the use of skip pointers ?