9.3.1 introduction distributed-computing is the application of multiple-computers connected by a network to solve a single problem . a distributed-computing-system can be viewed as a mimd parallel-processor with a relatively slow inter-processor-communication channel and the freedom to employ a heterogeneous collection of processors in the system . in fact , a single processing node in the distributed-system could be a parallel-computer in its own right . moreover , if they all support the same public interface and protocol for invoking their services , the computers in the system may be owned and operated by different parties . distributed-systems typically consist of a set of server processes , each running on a separate processing node , and a designated broker process responsible 250 parallel and distributed ir for accepting client requests , distributing the requests to the servers , collecting intermediate results from the servers , and combining the intermediate results into a final result for the client . this computation-model is very similar to the mimd parallel-processing model shown in figure 9.2 . the main difference here is that the subtasks run on different computers and the communication between the subtasks is performed using a network-protocol such as tcp/ip [176] (rather than , for example , shared memory-based inter-process-communication mechanisms) . another significant difference is that in a distributed-system it is more common to employ a procedure for selecting a subset of the distributed-servers for processing a particular request rather than broadcasting every request to every server in the system . applications that lend themselves well to a distributed-implementation usually involve computation and data that can be split into coarse-grained-operations with relatively little communication required between the operations . parallel-information-retrieval based on document-partitioning fits this profile well . in section 9.2.2 we saw how document-partitioning can be used to divide the search-task up into multiple , self-contained subtasks that each involve extensive computation and data-processing with little communication between them . moreover , documents are almost always grouped into collections , either for administrative purposes or to combine related documents into a single-source . collections , therefore , provide a natural granularity for distributing data across servers and partitioning the computation . note that since term partitioning imposes greater communication-overhead during query-processing , it is rarely employed in a distributed-system . to build a distributed-ir system , we need to consider both engineering issues common to many distributed-systems and algorithmic issues specific to information-retrieval . the critical engineering issues involve defining a search-protocol for transmitting requests and results ; designing a server that can efficiently accept a request , initiate a subprocess or thread to service the request , and exploit any locality inherent in the processing using appropriate caching-techniques ; and designing a broker that can submit asynchronous search requests to multiple-servers in parallel and combine the intermediate results into a final end-user response . the algorithmic issues include how to distribute documents across the distributed-search servers , how to select which servers should receive a particular search request , and how to combine the results from the different servers . the search-protocol specifies the syntax-and-semantics of messages transmitted between clients and servers , the säaquence of messages required to establish a connection and carry out a search operation , and the underlying transport mechanism for sending messages (e.g. , tcp/ip) . at a minimum , the protocol should allow a client to : obtain information about a search-server , e.g. , a list of databases available for searching at the server and possibly statistics associated with the databases ; distributed-ir 251 æ submit a search request for one or more databases using a well defined query-language ; æ receive search-results in a well denned format ; ï retrieve items identified in the search-results . for closed-systems consisting of homogeneous search servers , a custom search-protocol may be most appropriate , particularly if special functionality (e.g. , encryption of requests and results) is required . alternatively , a standard protocol may be used , allowing the system to interoperate more easily with other search servers . the z39 .50 [606] standard (see chapter 4) for client/server information-retrieval defines a widely used protocol with enough functionality to support most search-applications . another proposed protocol for distributed , heterogeneous search , called starts (stanford proposal for internet meta-searching) [317] , was developed at stanford-university in cooperation with a consortium of search product and service vendors . starts was designed from scratch to support distributed-information-retrieval and includes features intended to solve the algorithmic issues related to distributed-ir , such as merging results from heterogeneous-sources . the other engineering issues related to building efficient client/server-systems have been covered extensively in the literature (see , for example , comer and stevens [176] and zomaya [852]) . rather than review them here , we continue with a more detailed look at the algorithmic issues involved in distributed-ir .