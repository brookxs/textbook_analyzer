11.3.4 some proposals in the following we briefly survey some query-languages supporting retrieval of multimedia objects . in order to describe how standard languages are evolving to support multimedia-applications , we first describe the facilities provided by the upcoming standard sql3 to support such kinds of applications . then , we present the query-language supported by the multos system [90] , introduced in section 11.2.2 . the sql3 query-language as we have seen in section 11.2.1 , the extensible type-system and in general the ability to deal with complex-objects make sql3 suitable for modeling multimedia-data . from the query-language point-of-view , the major improvements of sql3 with respect to sql-92 can be summarized as follows : ï functions and stored procedures . sql3 allows the user to integrate external functionalities with data-manipulation . this means that functions of an external library can be introduced into a database-system as external functions . such functions can be either implemented by using an external language , and in this case sql3 only specifies which is the language and where the function can be found , or can be directly implemented by using sql3 itself . in this way , impedance-mismatch between two different programming-languages and type-systems is avoided . of course , this approach requires an extension of sql with imperative-programming languages constructs . ï active-database facilities . another important property of sql3 is the support of active-rules , by which the database is able to react to some system - or user-dependent events by executing specific actions . active-rules , or triggers , are very useful to enforce integrity-constraints . from the multimedia perspective point-of-view , the aspects described make sql3 suitable for being used as an-interface language for multimedia-applications , in particular , the ability to deal with external functions and user-defined data-types enables the language to deal with objects with a complex structure , as multimedia objects . note that , without this characteristic , the ability to deal with blob would have been useless since it reduces the view of multimedia-data to single large uninterpreted data-values , which are not adequate for the rich semantics of multimedia-data . by the use of triggers , spatial and temporal constraints can be enforced , thus preserving the database-consistency . finally , as sql3 is a widespread standard , it allows one to model multimedia objects in the framework of a well understood technology . query-languages 339 though the above facilities make sql3 suitable for use as an-interface for multimedia-applications , there are also some limitations . the main drawback is related to retrieval support and , as a consequence , optimization . indeed , no ir techniques are integrated into the sql3 query-processor . this means that the ability to perform content-based-search is application dependent . as a consequence , objects are not ranked and are therefore returned to the application as a unique set . moreover , specialized indexing-techniques can be used but they are not transparent to the user . bearing in mind the previous limitations , several projects have already been started with the aim of integrating sql3 with ir facilities . an example of such a project is represented by sql/mm pull text [190] . text is in this case considered as a nested sequence of words , sentences , and paragraphs . in order to precisely capture the structure and the meaning of the words , sql/mm full text is also able to view the text as a tree-structure entity . the structure of this entity is controlled by a grammar . these facilities allow one to easily express queries to perform selection on the basis of the text-content and/or text-structure . there have also been several proposals for introducing spatial-data types and predicates into the sql framework . among them , we recall probe [623] , spatial sql [231] , pictorial sql [687] , and qbe [418] . the multos query-language the development of the multos query-language has been driven by a number of requirements : first , it should be possible to easily navigate through the document structure . path-names can be used for this purpose . path-names can be total , if the path identifies only one component , or partial , if several components are identified by the path . path-names are similar to object-oriented path-expressions . queries both on the content and on document-structure must be supported . query predicates on complex-components must be supported . in this case , the predicate applies to all the document subcomponents that have a type compatible with the type required by the query . this possibility is very useful when a user does not recall the structure of a complex component . in general , a multos query has the form : find documents version version-clause scope scope-clause type type-clause where condition-clause with component where : the version-clause specifies which versions of the documents should be considered by the query . 340 multimedia-ir : models and languages æ the scope-clause restricts the query to a particular set of documents . this set of documents is either a user-defined document-collection or a set of documents retrieved by a previous query . ï the type-clause allows the restriction of a query to documents belonging to a prespecifled set of types . the conditions expressed by the condition-clause only apply to the documents belonging to these types and their subtypes . when no type is specified , the query is applied to all document types . æ the condition-clause is a boolean-combination of simple conditions (i.e. , predicates) on documents components . predicates are expressed on conceptual components of documents . conceptual components are referenced by path-names . the general form of a predicate is : component restriction where component is a path-name and restriction is an operator followed by an expression . ï the with-clause allows one to express structural predicates . component is a path-name and the clause looks for all documents structurally containing such a component . different types of conditions can be specified in order to query different types of media . in particular , multos supports three main classes of predicates : predicates on data attributes , on which an exact-match search is performed ; predicates on textual components , determining all objects containing some specific strings ; and predicates on images , specifying conditions on the image-content . image predicates allow one to specify conditions on the class to which an image should belong or conditions on the existence of a specified object within an image and on the number of occurrences of an object within an image . the following example illustrates the basic features of the multos query-language . example 2 consider the conceptual-structure genericjletter , presented in example 1 . the following is an example of query : find document versions last where document.date gt ; 1/1/1998 and (* sendei \ name = `` olivetti '' or * product_presentation contains `` olivetti '') amd * prodtict_description contains `` personal computer11 and (? address.country = `` italy '' or text contains `` italy '') and with * company_logo . according to this query , the user looks for the last version of all documents , dated after january 1998 , containing a company logo , having the word ` olivetti ' either as sender-name or in the product presentation (which is a textual component) , with the word ` personal-computer ' in the product description section trends and research-issues 341 (which is another textual component) and with the word ` italy ' either constituting the country in the address or contained in any part of the entire document . symbol ' * ' indicates that the path-name is not complete , that is , it could identify more than one component . the query-language provided by multos also supports the specification of imprecise-queries that can be used when the user has an uncertain-knowledge about the content of the documents he/she is seeking [657] . such uncertainty is expressed by associating both a preference and an importance value with the attributes in the query . such values are then used for ranking the retrieved documents . the following example illustrates the discussion . example 3 the query : find document versions last where (document.date between (12/31/1998 ,1 / 31/98) preferred between (2/1/1998 ,2 / 15/98) acceptable) high and (* sender.name = `` olivetti '' or * product_presentation contains `` olivetti '') high and (* productj) escription contains `` personal-computer '') high and (* productjdescription contains `` good ergonomics '') low and (? address.country = `` italy '' or text contains `` italy '') high and with * companyjlogo high (image matches screen high keyboard high at least 2 floppy . drives low) high finds the last versions of all documents written in january , but possibly even at the beginning of february 1998 , containing a company logo , having the word ` olivetti ' either as sender-name or in the product presentation , with the word ` personal-computer ' in the product description section , and with the word ` italy ' either constituting the country in the address or contained in any part of the entire document . personal-computers are described in the product description section as products having good ergonomics . moreover , the document should contain a picture of the personal-computer , complete with screen and keyboard , with at least two floppy drives . the value fl0w3 associated with the condition on ` good ergonomics7 indicates that the user formulating the query is not completely sure about this description of pc . by contrast , he/she is sure of all the conditions whose associated value is high .7