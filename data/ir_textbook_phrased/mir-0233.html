12.1 introduction the problem we focus on here is the design of fast searching methods that will search a database of multimedia objects to locate objects that match a query object , exactly or approximately . objects can be two-dimensional color-images , gray-scale medical-images in 2d or 3d (e.g. , mri brain scans) , one-dimensional time-series , digitized voice or music , video-clips , etc. . a typical query-by-content would be , e.g. , ` zn a collection of color photographs , find ones with the same color-distribution as a sunset photograph . ' specific applications include image-databases ; financial , marketing and production time-series ; scientific-databases with vector-fields ; audio and video databases ; dna/genorne databases ; etc. . in such databases , typical queries would be '' find companies whose stock prices move similarly , '' or ` find images that look like a sunset ^ or cfind medical x-rays that contain something that has the texture of a tumor . '' searching for similar patterns in such databases as the above is essential , because it helps in predictions , computer-aided medical-diagnosis and teaching , hypothesis-testing and , in general , in ` data-mining ' [8] and rule-discovery . of course , the distance of two objects has to be quantified . we rely on a domain expert to supply such a distance-function definition given two objects , o \ and 02 , the distance (= dissimilarity) of the two objects is denoted by tgt ; (ouo2) (12.1) for example , if the objects are two (equal-lengt . h) time-series , the distance v {-rrb- could be their euclidean-distance (the root of the sum of squared differences) . similarity-queries can been classified into two categories ; 345 346 multimedia-ir : indexing and searching ï whole match given a collection of n objects oi , 0 % , ... , on and a query object q , we want to find those data objects that are within distance s from q. notice that the query and the objects are of the same type : for example , if the objects are 512 x 512 gray-scale images , so is the query . ï sub-pattern match here the query is allowed to specify only part of the object . specifically , given n data objects (e.g. , images) oi , o2 , ï ï ï , on , a query (sub -) object q and a tolerance # , we want to identify the parts of the data objects that match the query . if the objects are , e.g. , 512x512 gray-scale images (like medical x-rays) , in this case the query could be , e.g. , a 16x16 subpattern (e.g. , a typical x-ray of a tumor) . additional types of queries include the cnearest neighbors '' queries (e.g. , ` find the five most similar stocks to ibm 's stock9) and the ` all pairs '' queries or `` spatial-joins ' (e.g. , ` report all the pairs of stocks that are within distance e from each other ') . both the above types of queries can be supported by the approach we describe next . as we shall see , we reduce the problem into searching for multi-dimensional points , which will be organized in r-trees ; in this case , nearest-neighbor-search can be handled with a branch-and-bound-algorithm and the spatial-join query can be handled with recent , highly fine-tuned algorithms , as discussed in section 12.8 . thus , we do not focus on nearest-neighbor and ` all-pairs ' queries . for all the above types of queries , the ideal method should fulfill the following requirements : ï it should be fast . sequential-scanning and distance-calculation with each and every object will be too slow for large-databases . ï it should be ` correct ' in other words , it should return all the qualifying objects , without missing any (i.e. , no ` false dismissals ') . notice that ` false-alarms '' are acceptable , since they can be discarded easily through a postprocessing step . of course , as we see , e.g. in figure 12.5 , we try to keep their number low (but not necessarily minimal) , so that the total response-time is minimized . ï the ideal method should require a small-space overhead . ï the method should be dynamic . it should be easy to insert , delete , and update objects . as we see next , the heart of the presented ` gemini * approach is to use / feature-extraction functions to map objects into points in / - dimensional space ; thus , we can use highly fine-tuned database spatial-access-methods to accelerate the search . the remainder of the chapter is organized as follows . section 12.2 gives some background material on past related work on spatial-access-methods . section 12.3 describes the main ideas for gemini , a generic-approach to indexing multimedia objects . section 12.4 shows the application of the approach for id time-series indexing . section 12.5 gives another case-study , for color-images . background ó spatial-access-methods 347 within the qbic project . section 12.6 presents ` fastmap ' , a method to do automatic-feature-extraction . section 12.7 summarizes the conclusions and lists problems for future-research and section 12.8 provides pointers to the related bibliography .