12.3 a generic multimedia-indexing approach to illustrate the basic idea , we shall focus on ` whole match ' queries . for such queries the problem is defined as follows : ï we have a collection of a '' objects : oi , o2 , ... , o4 \ - . ï the distance/dissimilarity between two objects (oi ^ oj) is given by the function t) (ot , o3) , which can be implemented as a (possibly , slow) pro-grain . ï the user specifies a query object q * and a tolerance e . a generic multimedia-indexing approach 349 our goal is to find the objects in the collection that are within distance e from the query object . an obvious solution is to apply sequential-scanning : for each and every object oi (1 lt ; i lt ; jv) , we can compute its distance from q and report the objects with distance tgt ; (q , oi) lt ; e. however , sequential-scanning may be slow , for two reasons : (1) the distance-computation might be expensive . for example , as discussed in chapter 8 , the editing distance in dna strings requires a dynamic-programming-algorithm , which grows like the product of the string lengths (typically , in the hundreds or thousands , for dna databases) . (2) the database-size n might be huge . thus , we are looking for a faster alternative . the gemini (generic multimedia-object indexing) approach we present next , is based on two ideas , each of which tries to avoid each of the two disadvantages of sequential-scanning : æ a ` quick-and-dirty ' test , to discard quickly the vast majority of nonqualifying objects (possibly , allowing some false-alarms) ; æ the use of spatial-access-methods , to achieve faster-than-sequential searching . the case is best illustrated with an example . consider a database of time-series , such as yearly stock price movements , with one price per day . assume that the distance-function between two such series s and q is the euclidean-distance v (s , q) = where s [i] stands for the value of stock s on the z-th day . clearly , computing the distance of two stocks will take 365 subtractions and 365 squarings in our example . the idea behind the quick-and-dirty test is to characterize a sequence with a single number , which will help us discard many non-qualifying sequences . such a number could be , e.g. , the average stock price over the year . clearly , if two stocks differ in their averages by a large-margin , it is impossible that they will be similar . the converse is not true , which is exactly the reason we may have false-alarms . numbers that contain some information about a sequence (or a multimedia-object , in general) , will be referred to as ` features for the rest of this chapter . using a good feature (like the ` average , ' in the stock prices example) , we can have a quick test , which will discard many stocks , with a single numerical comparison for each sequence (a big gain over the 365 subtractions and squarings that the original distance-function requires) . if using one feature is good , using two or more features might be even better , because they may reduce the number of false-alarms (at the cost of 350 multimedia-ir : indexing and searching making the quick-and-ciirty test a bit more elaborate and expensive) . in our stock prices example , additional features might be , e.g. , the standard-deviation , or , even better , some of the discrete-fourier-transform (dft) coefficients , as we shall see in section 12.4 . the end result of using / features for each of our objects is that we can map each object into a point in / - dimensional space . we shall refer to this mapping as t (-rrb- (for t'eature) : definition let jf (-rrb- be the mapping of objects to f-dimensional points , that is , t (o) will be the f-d point that corresponds to object o . this mapping provides the key to improve on the second drawback of sequential-scanning : by organizing these f-d points into a spatial-access-method , we can cluster them in a hierarchical-structure , like the r * - trees . upon a query , we can exploit the i ? * - tree , to prune out large portions of the database that are not promising . thus , we do not even have to do the quick-and-dirty test on all of the f-d points ! figure 12.3 illustrates the basic idea : objects (e.g. , time-series that are 365 points long) are mapped into 2d points (e.g. , using the average and the standard-deviation as features) . consider the ` whole match ' query that requires all the objects that are similar to sn within tolerance e : this query becomes an f-d sphere in feature-space , centered on the image j - (sn) of sn . such queries on multidimensional points is exactly what r-trees and other sams are designed to answer efficiently . more specifically , the search-algorithm for a wthole match query is as follows : feature2 / ' \ / 365 i , . ' feature 1 i 365 figure 12.3 illustration of the basic idea : a database of sequences s \ ... s.v ; each sequence is mapped to a point in feature-space ; a query with tolerance s becomes a sphere of radius 5 . a generic multimedia-indexing approach 351 algorithm 1 search : (1) map the query object q into a point f (q) in feature-space . (2) using a spatial-access-method , retrieve all points within the desired tolerance e fromf (q) . (3) retrieve the corresponding-objects , compute their actual distance from q and discard the false-alarms . intuitively , the method has the potential to relieve both problems of the sequential-scan , presumably resulting in much faster searches . the only step that we have to be careful with is that the mapping ! f (-rrb- from objects to / - d points does not distort the distances . let v {-rrb- be the distance-function of two objects , and vfeature (-rrb- be the (say , euclidean) distance of the corresponding feature-vectors . ideally , the mapping should preserve the distances exactly , in which case the sam will have neither false-alarms nor false dismissals . however , requiring perfect distance preservation might be difficult . for example , it is not obvious which features we have to use to match the editing distance between two dna strings . even if the features are obvious , there might be practical-problems : for example , in the stock price example , we could treat every sequence as a 365-dimensional vector ; although in theory a sam can support an arbitrary number of dimensions , in practice they all suffer from the ` dimensionality-curse , ' as discussed earlier . the crucial observation is that we can guarantee that there will be no false dismissals if the distance in feature-space matches or underestimates the distance between two objects . intuitively , this means that our mapping t (-rrb- from objects to points should make things look closer (i.e. , it should be a contractive mapping) . mathematically , let o \ and o2 be two objects (e.g. , same-length sequences) with distance-function v (-rrb- (e.g. , the euclidean-distance) and f (o \) , f {02) be their feature-vectors (e.g. , their first few fourier-coefficients) , with distance-function vfeaiure (-rrb- (e.g. , the euclidean-distance , again) . then we have : lemma 12.1 (lower-bounding) to guarantee no false dismissals for whole-match queries , the feature-extraction function p (-rrb- should satisfy the following formula : vfeature {hoi) , f (o2)) lt ; v {ouo2) (12.3) as proved in [249] , lower-bounding the distance works correctly for range-queries . will it work for the other queries of interest , like `` all pairs '' and ` nearest-neighbor ' ones ? the answer is affirmative in both cases . an `` all pairs * query can easily be handled by a `` spatial-join '' on the points of the feature-space : using a similar reasoning as before , we see that the resulting set of pairs will be a superset of the qualifying pairs . for the nearest-neighbor-query , the following algorithm guarantees no false dismissals : (1) find the point t {p) that is the 352 multimedia-ir : indexing and searching nearest-neighbor to the query point ! f (q) , (2) issue a range-query , with query object q and radius e = u (q , p) (i.e. , the actual distance between the query object q and data object p) . in conclusion , the gemini approach to indexing multimedia objects for fast similarity-searching is as follows : algorithm 2 (gemini) generic multimedia-object indexing-approach : (1) determine the distance-function tgt ;(-rrb- between two objects . (2) find one or more numerical feature-extraction functions , to provide a ` quick-and-dirty ' test . (3) prove that the distance in feature-space lower-bounds the actual distance tgt ;(-rrb- , to guarantee correctness . (4) use a sam (e.g. , an r-tree) , to store and retrieve the f-d feature-vectors . the first two steps of gemini deserve some more discussion : the first step involves a domain expert . the methodology focuses on the speed of search only ; the quality of the results is completely relying on the distance-function that the expert will provide . thus , gemini will return exactly the same response set (and therefore , the same quality of output , in terms of precision-recall) that would be returned by a sequential-scanning of the database ; the only difference is that gemini will be faster . the second step of gemini requires intuition and imagination . it starts by trying to answer the question (referred to as the ` feature-extracting ' question for the rest of this chapter) : ` feature-extracting ' question : if we are allowed to use only one numerical feature to describe each data object , what should this feature be ? the successful answers to the above question should meet two goals : first , they should facilitate step 3 (the distance lower-bounding) , and second , they should capture most of the characteristics of the objects . we give case-studies of steps 2 and 3 of the gemini algorithm in the following sections . the first involves id time-series , and the second focuses on 2d color images . we shall see that the philosophy of the quick-and-dirty filter , in conjunction with the lower-bounding lemma , can lead to solutions to two problems : ï the dimensionality-curse (time-series) ï the ` cross-talk ' of features (color-images) . for each case-study , we first describe the objects and the distance-function , then show how to apply the lower-bounding lemma , and finally give experimental-results , on real or realistic data . one-dimensional time-series 353