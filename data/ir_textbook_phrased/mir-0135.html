8.1 introduction chapter 4 describes the query-operations that can be performed on text-databases . in this chapter we cover the main techniques we need to implement those query-operations . we first concentrate on searching queries composed of words and on reporting the documents where they are found . the number of occurrences of a query in each document and even its exact positions in the text may also be required . following that , we concentrate on algorithms dealing with boolean-operations . we then consider sequential search-algorithms and pattern-matching . finally , we consider structured-text and-compression techniques . an obvious option in searching for a basic query is to scan the text sequentially . sequential or online text searching involves finding the occurrences of a pattern in a text when the text is not preprocessed . online searching is appropriate when the text is small (i.e. , a few megabytes) , and it is the only choice if the text-collection is very volatile (i.e. , undergoes modifications very frequently) or the index-space overhead can not be afforded . a second option is to build data-structures over the text (called indices) to speed up the search . it is worthwhile building and maintaining an index when the text-collection is large and semi-static . semi-static collections can be updated at reasonably regular intervals (e.g. , daily) but they are not deemed to support thousands of insertions of single words per second , say . this is the case for most real text-databases , not only dictionaries or other slow growing literary works . for instance , it is the case for web-search-engines or journal archives . nowadays , the most successful techniques for medium size databases (say up to 200mb) combine online and indexed searching . we cover three main indexing-techniques : inverted-files , suffix-arrays , and signature-files . keyword-based-search is discussed first . we emphasize inverted-files , which are currently the best choice for most applications . suffix-trees 191 192 indexing and searching and arrays are faster for phrase searches and other less common queries , but are harder to build and maintain . finally , signature-files were popular in the 1980s , but nowadays inverted-files outperform them . for all the structures we pay attention not only to their search-cost and space overhead , but also to the cost of building and updating them . we assume that the reader is familiar with basic data-structures , such as sorted arrays , binary-search-trees , b-trees , hash-tables , and tries . since tries are heavily used we give a brief and simplified reminder here . tries , or digital search-trees , are multiway-trees that store sets of strings and are able to retrieve any string in time proportional to its length (independent of the number of strings stored) . a special character is added to the end of the string to ensure that no string is a prefix of another . every edge of the tree is labeled with a letter . to search a string in a trie , one starts at the root and scans the string character-wise , descending by the appropriate edge of the trie . this continues until a leaf is found (which represents the searched string) or the appropriate edge to follow does not exist at some point (i.e. , the string is not in the set) . see figure 8.3 for an example of a text and a trie built on its words . although an index must be built prior to searching it , we present these tasks in the reverse order . we think that understanding first how a data-structure is used makes it clear how it is organized , and therefore eases the understanding of the construction algorithm , which is usually more complex . throughout this chapter we make the following assumptions . we call n the size of the text-database . whenever a pattern is searched , we assume that it is of length m , which is much smaller than n . we call m the amount of main-memory available . we assume that the modifications which a text-database undergoes are additions , deletions , and replacements (which are normally made by a deletion plus an addition) of pieces of text of size n1 lt ; n . we give experimental measures for many algorithms to give the reader a grasp of the real times involved . to do this we use a reference-architecture throughout the chapter , which is representative of the power of today 's computers . we use a 32-bit sun ultrasparc-1 of 167 mhz with 64 mb of ram , running solaris . the code is written in c and compiled with all optimization options . for the text-data , we use collections from trec-2 , specifically wsj , doe , fr , ziff and ap . these are described in more detail in chapter 3 .