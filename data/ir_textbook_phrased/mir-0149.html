8.5.6 practical comparison figure 8.20 shows a practical comparison between string-matching algorithms run on our reference machine . the values are correct within b % of accuracy with a 9f/4 confidence-interval . we tested english-text from the trec collection , dna (corresponding to ii.iiiflueiizae *) and random text uniformly generated over 64 letters . the patterns were randomly selected from the text except for random pattern matching 215 text , where they were randomly generated . we tested over 10 mb of text and measured cpu-time . we tested short patterns on english and random text and long patterns on dna , which are the typical cases . we first analyze the case of random text , where except for very short patterns the clear winners are bndm (the bit-parallel implementation of bdm) and the bms (sunday) algorithm . the more classical boyer-moore and bdm algorithms are also very close . among the algorithms that do not improve with the pattern length , shift-or is the fastest , and kmp is much slower than the naive algorithm . the picture is similar for english-text , except that we have included the agrep software in this comparison , which worked well only on english-text . agrep turns out to be much faster than others . this is not because of using a special algorithm (it uses a bm-family algorithm) but because the code is carefully optimized . this shows the importance of careful coding as well as using good algorithms , especially in text-searching where a few operations per text character are performed . longer patterns are shown for a dna text . bndm is the fastest for moderate patterns , but since it does not improve with the length after m gt ; w , the classical bdm finally obtains better times . they are much better than the boyer-moore family because the alphabet is small and the suffix automaton technique makes better use of the information on the pattern . we have not shown the case of extended patterns , that is , where flexibility plays a role . for this case , bndm is normally the fastest when it can be applied (e.g. , it supports classes of characters but not wild cards) , otherwise shift-or is the best option . shift-or is also the best option when the text must be accessed sequentially and it is not possible to skip characters .