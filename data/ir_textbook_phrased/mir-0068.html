4.1 introduction we cover in this chapter the different kinds of queries normally posed to text-retrieval-systems . this is in part dependent on the retrieval-model the system adopts , i.e. , a full-text system will not answer the same kinds of queries as those answered by a system based on keyword ranking (as web-search-engines) or on a hypertext-model . in chapter 8 we explain how the user queries are solved , while in this chapter we show which queries can be formulated . the type of query the user might formulate is largely dependent on the underlying information-retrieval-model . the different models for text-retrieval-systems are covered in chapter 2 . as in previous chapters , we want to distinguish between information-retrieval and data-retrieval , as we use this dichotomy to classify different query-languages . we have chosen to distinguish first languages that allow the answer to be ranked , that is , languages for information-retrieval . as covered in chapter 2 , for the basic information-retrieval-models , keyword-based-retrieval is the main type of querying task . for query-languages not aimed at information-retrieval , the concept of ranking can not be easily defined , so we consider them as languages for data-retrieval . furthermore , some query-languages are not intended for final users and can be viewed as languages that a higher level software package should use to query an on-line database or a cd-rom archive . in that case , we talk about protocols rather than query-languages . depending on the user-experience , a different query-language will be used . for example , if the user knows exactly what he wants , the retrieval-task is easier and ranking may not even be needed . an important issue is that most query-languages try to use the content (i.e. , the semantics) and the structure of the text (i.e. , the text syntax) to find relevant documents . in that sense , the system may fail to find the relevant answers (see chapter 3) . for this reason , a number of techniques meant to enhance the usefulness of the queries exist . examples include the expansion of a word to the set of its synonyms or the use of a thesaurus and stemming to 99 100 query-languages put together all the derivatives of the same word . moreover , some words which are very frequent and do not carry meaning (such as ` the ') , called stopwords , may be removed . this subject is covered in chapter 7 . here we assume that all the query-preprocessing has already been done . although these operations are usually done for information-retrieval , many of them can also be useful in a data-retrieval context . when we want to emphasize the difference between words that can be retrieved by a query and those which can not , we call the former ` keywords . ' orthogonal to the kind of queries that can be asked is the subject of the retrieval-unit the information-system adopts . the retrieval-unit is the basic element which can be retrieved as an answer to a query (normally a set of such basic elements is retrieved , sometimes ranked by relevance or other criterion) . the retrieval-unit can be a file , a document , a web-page , a paragraph , or some other structural unit which contains an answer to the search-query . prom this point on , we will simply call those retrieval units ` documents , ' although as explained this can have different meanings (see also chapter 2) . this chapter is organized as follows . we first show the queries that can be formulated with keyword-based query languages . they are aimed at information-retrieval , including simple words and phrases as well as boolean-operators which manipulate sets of documents . in the second section we cover pattern-matching , which includes more complex-queries and is generally aimed at complementing keyword searching with more powerful data-retrieval capabilities . third , we cover querying on the structure of the text , which is more dependent on the particular text model . finally , we finish with some standard protocols used on the internet and by cd-rom publishers .