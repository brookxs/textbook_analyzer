k-gram indexes for wildcard queries whereas the permuterm index is simple , it can lead to a considerable blowup from the number of rotations per term ; for a dictionary of english terms , this can represent an almost ten-fold space increase . we now present a second technique , known as the - gram index , for processing wildcard queries . we will also use - gram indexes in section 3.3.4 . a - gram is a sequence of characters . thus cas , ast and stl are all 3-grams occurring in the term castle . we use a special character $ to denote the beginning or end of a term , so the full set of 3-grams generated for castle is : $ ca , cas , ast , stl , tle , le $ . in a - gram index , the dictionary contains all - grams that occur in any term in the vocabulary . each postings list points from a - gram to all vocabulary terms containing that - gram . for instance , the 3-gram etr would point to vocabulary terms such as metric and retrieval . an example is given in figure 3.4 . how does such an index help us with wildcard queries ? consider the wildcard query re * ve . we are seeking documents containing any term that begins with re and ends with ve . accordingly , we run the boolean-query $ re and ve $ . this is looked up in the 3-gram index and yields a list of matching terms such as relive , remove and retrieve . each of these matching terms is then looked up in the standard inverted-index to yield documents matching the query . there is however a difficulty with the use of - gram indexes , that demands one further step of processing . consider using the 3-gram index described above for the query red * . following the process described above , we first issue the boolean-query $ re and red to the 3-gram index . this leads to a match on terms such as retired , which contain the conjunction of the two 3-grams $ re and red , yet do not match the original wildcard query red * . to cope with this , we introduce a post-filtering step , in which the terms enumerated by the boolean-query on the 3-gram index are checked individually against the original query red * . this is a simple string-matching operation and weeds out terms such as retired that do not match the original query . terms that survive are then searched in the standard inverted-index as usual . we have seen that a wildcard query can result in multiple terms being enumerated , each of which becomes a single-term query on the standard inverted-index . search-engines do allow the combination of wildcard queries using boolean-operators , for example , re * d and fe * ri . what is the appropriate semantics for such a query ? since each wildcard query turns into a disjunction of single-term queries , the appropriate interpretation of this example is that we have a conjunction of disjunctions : we seek all documents that contain any term matching re * d and any term matching fe * ri . even without boolean combinations of wildcard queries , the processing of a wildcard query can be quite expensive , because of the added lookup in the special index , filtering and finally the standard inverted-index . a search-engine may support such rich functionality , but most commonly , the capability is hidden behind an-interface (say an `` advanced query '' interface) that most users never use . exposing such functionality in the search-interface often encourages users to invoke it even when they do not require it (say , by typing a prefix of their query followed by a *) , increasing the processing-load on the search-engine . exercises . in the permuterm index , each permuterm vocabulary term points to the original vocabulary term (s) from which it was derived . how many original vocabulary terms can there be in the postings list of a permuterm vocabulary term ? write down the entries in the permuterm index dictionary that are generated by the term mama . if you wanted to search for s * ng in a permuterm wildcard index , what key (s) would one do the lookup on ? refer to figure 3.4 ; it is pointed out in the caption that the vocabulary terms in the postings are lexicographically ordered . why is this ordering useful ? consider again the query fi * mo * er from section 3.2.1 . what boolean-query on a bigram index would be generated for this query ? can you think of a term that matches the permuterm query in section 3.2.1 , but does not satisfy this boolean-query ? give an example of a sentence that falsely matches the wildcard query mon * h if the search were to simply use a conjunction of bigrams .