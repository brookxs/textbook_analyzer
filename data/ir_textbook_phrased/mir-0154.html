8.6.3 pattern-matching using indices we end this section by explaining how the indexing-techniques we presented for simple searching of words can in fact be extended to search for more complex patterns . inverted-files as inverted-files are word-oriented , other types of queries such as suffix or substring queries , searching allowing errors and regular-expressions , are solved by a sequential (i.e. , online) search over the vocabulary . this is not too bad since the size of the vocabulary is small with respect to the text size . after either type of search , a list of vocabulary words that matched the query is obtained . all their lists of occurrences are now merged to retrieve a list of documents and (if required) the matching text positions . if block addressing is used and the positions are required or the blocks do not coincide with the retrieval-unit , the search must be completed with a sequential search over the blocks . notice that an inverted-index is word-oriented . because of that it is not surprising that it is not able to efficiently find approximate matches or regular-expressions that span many words . this is a restriction of this scheme . variations that are not subject to this restriction have been proposed for languages which do not have a clear concept of word , like finnish . they collect text samples or n-grarns , which are fixed-length strings picked at regular text intervals . searching is in genera ! more powerful but more expensive . in a full-inverted index , search times for simple words allowing errors on 250 mb of text took out reference machine from 0.6 to 0,85 seconds , while very complex expressions on extended patterns took from 0.8 to 3 seconds . as a comparison , the same collection cut in blocks of 1 mb size takes more than 8 seconds for an approximate-search with one error and more than 20 for two errors . pattern-matching 221 suffix-trees and suffix-arrays if the suffix-tree indexes all text positions it can search for words , prefixes , suffixes and substrings with the same search-algorithm and cost described for word search . however , indexing all positions makes the index 10 to 20 times the text size for suffix-trees . range-queries are easily solved too , by just searching both extremes in the trie and then collecting all the leaves which lie in the middle . in this case the cost is the height of the tree , which is o (logn) on average (excluding the tasks of collecting and sorting the leaves) . regular-expressions can be searched in the suffix-tree . the algorithm simply simulates sequential-searching of the regular-expression . it begins at the root , since any possible match starts there too . for each child of the current node labeled by the character c , it assumes that the next text character is c and recursively enters into that subtree . this is done for each of the children of the current node . the search stops only when the automaton has no transition to follow . it has been shown that for random text only o (nq ; polylog (n)) nodes are traversed (for 0 lt ; a lt ; 1 dependent on the regular-expression) . hence , the search-time is sublinear for regular-expressions without the restriction that they must occur inside a word . extended patterns can be searched in the same way by taking them as regular-expressions . unrestricted approximate-string-matching is also possible using the same idea . we present a simplified version here . imagine that the search is online and traverse the tree recursively as before . since all suffixes start at the root , any match starts at the root too , and therefore do not allow the match to start later . the search will automatically stop at depth m - f - k at most (since at that point more than k errors have occurred) . this implies constant search-time if n is large enough (albeit exponential on m and k) . other problems such as approximate-search of extended patterns can be solved in the same way , using the appropriate online-algorithm . suffix-trees are able to perform other complex searches that we have not considered in our query-language (see chapter 4) . these are specialized operations which are useful in specific areas . some examples are : find the longest substring in the text that appears more than once , find the most common-substring of a fixed size , etc. . if a suffix-array indexes all text positions , any algorithm that works on suffix-trees at c (n) cost will work on suffix-arrays at o (c (n) log n) cost . this is because the operations performed on the suffix-tree consist of descending to a child node , which is done in o (l) time . this operation can be simulated in the suffix-array in o (logn) time by binary searching the new boundaries (each suffix-tree node corresponds to a string , which can be mapped to the suffix-array interval holding ail suffixes starting with that string) . some patterns can be searched directly in the suffix-array in o (logn) total search-time without simulating the suffix-tree . these are : word , prefix , suffix and subword search , as well as range-search . however , again , indexing all text positions normally makes the suffix-array 222 indexing and searching size four times or more the text size . a different alternative for suffix-arrays is to index only word beginnings and to use a vocabulary supra-index , using the same search-algorithms used for the inverted-lists .