1.3.1 item normalization the first step in any integrated-system is to normalize the incoming items to a-standard-format . in addition to translating multiple external formats that might be received into a single consistent-data structure that can be manipulated by the functional processes , item normalization provides logical restructuring of the item . additional operations during item normalization are needed to create a searchable data-structure : identification of processing tokens (e.g. , words) , characterization of the tokens , and stemming (e.g. , removing word endings) of the tokens . the original item or any of its logical subdivisions is available for the user to display . the processing tokens and their characterization are used to define the searchable text from the total received text . figure 1.5 shows the normalization-process . standardizing the input takes the different external formats of input data and performs the translation to the formats acceptable to the system . a system may have a single format for all items or allow multiple formats . one example of standardization could be translation of foreign languages into unicode . every language has a different internal binary-encoding for the characters in the language . one standard encoding that covers english , french , spanish , etc. is iso-latin . the are other internal encodings for other language groups such as introduction to information-retrieval-systems 11 russian (e.g , koi-7 , koi-8) , japanese , arabic , etc. . unicode is an evolving international standard based upon 16 bits (two bytes) that will be able to represent item input item normalization selective-dissemination-of-information (mail) document file-creation automatic file build (afb) co o o public indexing private indexing figure 1.4 total information-retrieval-system 12 chapter 1 standardize input logical subsetting (zoning) identify processing tokens update document file apply stoplists (stop algorithms) characterize tokens apply stemming create searchable data-structure figure 1.5 the text-normalization process all languages . unicode based upon utf-8 , using multiple 8-bit bytes , is becoming the practical unicode standard . having all of the languages encoded into a single format allows for a single browser to display the languages and potentially a single search-system to search them . of course such a search-engine would have to have the capability of understanding the linguistic-model for all the languages to allow for correct tokenization (e.g. , word-boundaries , stemming , word stop lists , etc.) of each language . introduction to information-retrieval-systems 13 multi-media adds an extra dimension to the normalization-process . in addition to normalizing the textual-input , the multi-media input also needs to be standardized . there are a lot of options to the standards being applied to the normalization . if the input is video the likely digital standards will be either mpeg-2 , mpeg-1 , avi or real media . mpeg (motion-picture-expert-group) standards are the most universal standards for higher quality video where real media is the most common standard for lower quality video being used on the internet . audio standards are typically wav or real media (real audio) . images vary from jpeg to bmp . in all of the cases for multi-media , the input analog source is encoded into a-digital format . to index the modal different encodings of the same input may be required (see section 1.3.5 below) . but the importance of using an encoding standard for the source that allows easy access by browsers is greater for multi-media then text that already is handled by all interfaces . the next process is to parse the item into logical sub-divisions that have meaning to the user . this process , called `` zoning , '' is visible to the user and used to increase the precision of a search and optimize the display . a typical item is sub-divided into zones , which may overlap and can be hierarchical , such as title , author , abstract , main text , conclusion , and references . the term `` zone '' was selected over field because of the variable-length nature of the data identified and because it is a logical sub-division of the total item , whereas the term `` fields '' has a connotation of independence . there may be other source-specific zones such as `` country '' and `` keyword . '' the zoning information is passed to the processing token-identification operation to store the information , allowing searches to be restricted to a specific zone . for example , if the user is interested in articles discussing `` einstein '' then the search should not include the bibliography , which could include references to articles written by `` einstein . '' zoning differs for multi-media based upon the source structure . for a news broadcast , zones may be defined as each news story in the input . for speeches or other programs , there could be different semantic boundaries that make sense from the user 's perspective . once a search is complete , the user wants to efficiently review the results to locate the needed information . a major limitation to the user is the size of the display screen which constrains the number of items that are visible for review . to optimize the number of items reviewed per display screen , the user wants to display the minimum data required from each item to allow determination of the possible relevance of that item . quite often the user will only display zones such as the title or title and abstract . this allows multiple-items to be displayed per screen . the user can expand those items of potential interest to see the complete text . once the standardization and zoning has been completed , information (i.e. , words) that are used in the search-process need to be identified in the item . the term-processing token is used because a `` word '' is not the most efficient unit on which to base search structures . the first step in identification of a processing token consists of determining a word . systems determine words by dividing input symbols into three classes : valid word symbols , inter-word symbols , and special processing symbols . a word is defined as a contiguous set of word symbols 14 chapter bounded by inter-word symbols . in many systems inter-word symbols are nonsearchable and should be carefully selected . examples of word symbols are alphabetic characters and numbers . examples of possible inter-word symbols are blanks , periods and semicolons . the exact definition of an inter-word symbol is dependent upon the aspects of the language domain of the items to be processed by the system . for example , an apostrophe may be of little importance if only used for the possessive case in english , but might be critical to represent foreign names in the database . based upon the required accuracy of searches and language characteristics , a trade-off is made on the selection of inter-word symbols . finally there are some symbols that may require special processing . a hyphen can be used many ways , often left to the taste and judgment of the writer (bernstein-84) . at the end of a line it is used to indicate the continuation of a word . in other places it links independent words to avoid absurdity , such as in the case of `` small-business men . '' to avoid interpreting this as short males that run businesses , it would properly be hyphenated `` small-business men . '' thus when a hyphen (or other special symbol) is detected a set of rules are executed to determine what action is to be taken generating one or more processing tokens . next , a stop list/algorithm is applied to the list of potential processing tokens . the objective of the stop function is to save system-resources by eliminating from the set of searchable processing tokens those that have little value to the system . given the significant increase in available cheap memory , storage and processing power , the need to apply the stop function to processing tokens is decreasing . nevertheless , stop lists are commonly found in most systems and consist of words (processing tokens) whose frequency and/or semantic use make them of no value as a searchable token . for example , any word found in almost every item would have no discrimination value during a search . parts-of-speech , such as articles (e.g. , `` the '') , have no search value and are not a useful part of a user 's query . by eliminating these frequently occurring words the system saves the processing and storage resources required to incorporate them as part of the searchable data-structure . stop algorithms go after the other class of words , those found very infrequently . ziph (ziph-49) postulated that , looking at the frequency of occurrence of the unique-words across a corpus of items , the majority of unique-words are found to occur a few times . the rank-frequency law of ziph is : frequency * rank = constant where frequency is the number of times a word occurs and rank is the rank-order of the word . the law was later derived analytically using probability and information-theory (fairthorne-69) . table 1.1 shows the distribution of words in the first trec test database (harman-93) , a database with over one billion characters and 500,000 items . in table li , wsj is wall-street-journal (1986-89) , ap is ap newswire (1989) , ziff - information from computer select disks , fr federal register (1989) , and doe - short abstracts from department-of-energy . introduction to information-retrieval-systems 15 the highly precise nature of the words only found once or twice in the database reduce the probability of their being in the vocabulary of the user and the terms are almost never included in searches . eliminating these words saves on storage and access structure (e.g. , dictionary - see chapter 4) complexities . the best technique to eliminate the majority of these words is via a stop algorithm versus trying to list them individually . examples of stop algorithms are : stop all numbers greater than `` 999999 '' (this was selected to allow dates to be searchable) stop any processing token that has numbers and characters intermixed the algorithms are typically source specific , usually eliminating unique item numbers that are frequently found in systems and have no search value . in some systems (e.g. , inquire dbms) , inter-word symbols and stop words are not included in the optimized search structure (e.g. , inverted-file structure , see chapter 4) but are processed via a scanning of potential hit documents after inverted-file search reduces the list of possible relevant items . other systems never allow interword symbols to be searched . source wsj ap ziff fr doe size in mbytes 295 266 251 258 190 median number terms/record 182 353 181 313 82 average number terms/record 329 375 412 1017 89 number unique terms 156,298 197,608 173,501 126,258 186,225 number of terms occurring once 64,656 89,627 85,992 58,677 95,782 average number terms occurrences gt ; 1 199 174 165 106 159 table li distribution of words in trec database (from trec-1 conference-proceedings , harmon-93) the next step in finalizing on processing tokens is identification of any specific word characteristics . the characteristic is used in systems to assist in disambiguation of a particular word . morphological-analysis of the processing 16 chapter 1 token 's part-of-speech is included here . thus , for a word such as `` plane , '' the system understands that it could mean `` level or flat '' as an adjective , `` aircraft or facet '' as a noun , or `` the act of smoothing or evening '' as a verb . other characteristics may classify a token as a member of a higher class of tokens such as `` european country '' or `` financial institution . '' another example of characterization is if upper case should be preserved . in most systems upper/lower case is not preserved to avoid the system having to expand a term to cover the case where it is the first word in a sentence . but , for proper-names , acronyms and organizations , the upper case represents a completely different use of the processing token versus it being found in the text . `` pleasant grant '' should be recognized as a person 's name versus a `` pleasant grant '' that provides funding . other characterizations that are typically treated separately from text are numbers and dates . once the potential processing token has been identified and characterized , most systems apply stemming algorithms to normalize the token to a standard semantic-representation . the decision to perform stemming is a trade-off between precision of a search (i.e. , finding exactly what the query specifies) versus standardization to reduce system overhead in expanding a search-term to similar token representations with a potential increase in recall . for example , the system must keep singular , plural , past tense , possessive , etc. as separate searchable tokens and potentially expand a term at search-time to all its possible representations , or just keep the stem of the word , eliminating endings . the amount of stemming that is applied can lead to retrieval of many non-relevant items . the major stemming algorithms used at this time are described in chapter 4 . some systems such as retrievalware , that use a large dictionary/thesaurus , looks up words in the existing dictionary to determine the stemmed version in lieu of applying a sophisticated algorithm . once the processing tokens have been finalized , based upon the stemming algorithm , they are used as updates to the searchable data-structure . the searchable data-structure is the internal-representation (i.e. , not visible to the user) of items that the user-query searches . this structure contains the semantic concepts that represent the items in the database and limits what a user can find as a result of their search . when the text is associated with video or audio multi-media , the relative time from the start of the item for each occurrence of the processing token is needed to provide the correlation between the text and the multi-media source . chapter 4 introduces the internal data-structures that are used to store the searchable data-structure for textual items and chapter 5 provides the algorithms for creating the data to be stored based upon the identified processing tokens .