4.5 pat data-structure using n-grams with interword symbols included between valid processing tokens equates to a continuous text-input data-structure that is being indexed in data-structure 89 contiguous `` n '' character tokens . a different view of addressing a continuous text-input data-structure comes from pat trees and pat arrays . the input stream is transformed into a searchable data-structure consisting of substrings . the original concepts of pat-tree data-structures were described as patricia-trees (flajolet-86 , frakes-92 , gonnet-83 , knuth-73 , and morrison-68) and have gained new momentum as a possible structure for searching text and images (gonnet-88) and applications in genetic databases (manber-90) . the name pat is short for patricia-trees (patricia stands for practical algorithm to retrieve information coded in alphanumerics .) in creation of pat trees each position in the input-string is the anchor point for a sub-string that starts at that point and includes all new text up to the end of the input . all substrings are unique . this view of text lends itself to many different search processing structures . it fits within the general architectures of hardware text-search machines and parallel processors (see chapter 9) . a substring can start at any point in the text and can be uniquely indexed by its starting location and length . if all strings are to the end of the input , only the starting location is needed since the length is the difference from the location and the total length of the item . it is possible to have a substring go beyond the length of the input stream by adding additional null characters . these substrings are called sistring (semi-infinite string) . figure 4.9 shows some possible sistrings for an input-text . a pat-tree is an unbalanced , binary digital tree defined by the sistrings . the individual bits of the sistrings decide the branching patterns with zeros branching left and ones branching right . pat trees also allow each node in the tree to specify which bit is used to determine the branching via bit position or the text economics for warsaw is complex . sistring 1 economics for warsaw is complex , sistring 2 conomics for warsaw is complex , sistring 5 omics for warsaw is complex , sistring 10 for warsaw is complex . sistring 20 w is complex . sistring 30 ex . figure 4.9 examples of sistrings number of bits to skip from the parent node . this is useful in skipping over levels that do not require branching . the key values are stored at the leaf nodes (bottom nodes) in the pat-tree . for a text-input of size fcv there are `` n '' leaf nodes and `` n-f at most higher level nodes . it is possible to place additional constraints on sistrings for the leaf nodes . we may be interested in limiting our searches to word-boundaries . 90 chapter 4 thus we could limit our sistrings to those that are immediately after an interword symbol . figure 4,10 gives an example of the sistrings used in generating a pat input 100110001101 sistring 1 1001 ... sistring2 001100 ... sistring 3 01100 ... sistring 4 11 ... . . sistring 5 1000 ... sistring 6 000 ... sistring 7 001101 sistring 8 01101 figure 4.10 sistrings for input `` 100110001101 '' tree . if the binary representations of `` h '' is (100) , `` o '' is (110) , `` m '' is (001) and ue '' is (101) then the word `` home '' produces the input 100110001101 ... using the sistrings , the frill pat binary-tree is shown in figure 4.11 . a more compact-tree where skip values are in the intermediate nodes is shown in figure 4.12 . in this version the value in the intermediate nodes (indicated by rectangles) is the number of bits to skip until the next bit to compare that causes differences between similar terms . this final version saves space , but requires comparing a search value to the leaf node (in an oval) contents to ensure the skipped bits match the search-term (i.e. , skipped bits are not compared) . the search-terms are also represented by their binary representation and the pat trees for the sistrings are compared to the search-terms looking for matches . as noted in chapter 2 , one of the most common classes of searches is prefix searches . pat trees are ideally constructed for this purpose because each sub-tree contains all the sistrings for the prefix defined up to that node in the tree-structure . thus all the leaf nodes after the prefix node define the sistrings that satisfy the prefix search criteria . this logically sorted order of pat trees also facilitates range searches since it is easy to determine the sub-trees constrained by the range values . if the total input stream is used in defining the pat-tree , then suffix , imbedded string , and fixed length masked searches (see section 2.1.5) are all easy because the given characters uniquely define the path from the root-node to where the existence of sistrings need to be validated . fuzzy searches are very difficult because large number of possible sub-trees could match the search-term . a detailed discussion on searching pat trees and their representation as an array is provided by gonnet , baeza-yates and snider (gonnet-92) . in their comparison to signature and inversion files , they concluded that pat arrays have more accuracy than signature-files and provide the ability to string searches that data-structure 91 1000 1001 001100 001101 figure 4.11 pat binary-tree for input `` 100110001101 ' 92 chapter 4 figure 4 . 12 pat-tree skipping bits for `` 100110001101 '' are inefficient in inverted-files (e.g. , suffix searches , approximate string searches , longest repetition) . pat trees (and arrays) provide an alternative structure if string-searching is the goal . they store the text in an alternative structure supporting string-manipulation . the structure does not have facilities to store more abstract-concepts and their relationships associated with an item . the structure has interesting potential applications , but is not used in any major commercial products at this time .