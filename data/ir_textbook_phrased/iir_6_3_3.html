computing vector scores free-text query 7 figure 6.14 : the basic algorithm for computing vector-space scores . figure 6.14 gives the basic algorithm for computing vector-space scores . the array length holds the lengths (normalization factors) for each of the documents , whereas the array scores holds the scores for each of the documents . when the scores are finally computed in step 9 , all that remains in step 10 is to pick off the documents with the highest scores . the outermost loop beginning step 3 repeats the updating of scores , iterating over each query-term in turn . in step 5 we calculate the weight in the query-vector for term . steps 6-8 update the score of each document by adding in the contribution from term . this process of adding in contributions one query-term at a time is sometimes known as term-at-a-time scoring or accumulation , and the elements of the array are therefore known as accumulators . for this purpose , it would appear necessary to store , with each postings entry , the weight of term in document (we have thus far used either tf or tf-idf for this weight , but leave open the possibility of other functions to be developed in section 6.4) . in fact this is wasteful , since storing this weight may require a floating-point number . two ideas help alleviate this space problem . first , if we are using inverse-document-frequency , we need not precompute ; it suffices to store at the head of the postings for . second , we store the term-frequency for each postings entry . finally , step 12 extracts the top scores - this requires a priority-queue data-structure , often implemented using a heap . such a heap takes no more than comparisons to construct , following which each of the top scores can be extracted from the heap at a cost of comparisons . note that the general algorithm of figure 6.14 does not prescribe a specific implementation of how we traverse the postings lists of the various-query terms ; we may traverse them one term at a time as in the loop beginning at step 3 , or we could in fact traverse them concurrently as in figure 1.6 . in such a concurrent postings traversal we compute the scores of one document at a time , so that it is sometimes called document-at-a-time scoring . we will say more about this in section 7.1.5 . exercises . if we were to stem jealous and jealousy to a common stem before setting-up the vector-space , detail how the definitions of tf and idf should be modified . recall the tf-idf weights computed in exercise 6.2.2 . compute the euclidean normalized document-vectors for each of the documents , where each vector has four components , one for each of the four terms . verify that the sum of the squares of the components of each of the document vectors in exercise 6.3.3 is 1 (to within rounding-error) . why is this the case ? with term-weights as computed in exercise 6.3.3 , rank the three documents by computed score for the query car-insurance , for each of the following cases of term-weighting in the query : the weight of a term is 1 if present in the query , 0 otherwise . euclidean normalized idf .