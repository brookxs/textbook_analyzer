8.3.1 suffix-trees and suffix-arrays inverted-indices assume that the text can be seen as a sequence of words . this restricts somewhat the kinds of queries that can be answered . other queries such as phrases are expensive to solve . moreover , the concept of word does not exist in some applications such as genetic databases . in this section we present suffix-arrays . suffix-arrays are a space-efficient implementation of suffix-trees . this type of index allows us to answer efficiently more complex-queries . its main drawbacks are its costly construction process , that the text must be readily available at query time , and that the results are not delivered in text position order . this structure can be used to index only words (without stopwords) as the inverted-index as well as to index any text character . this makes it suitable for a wider spectrum of applications , such as genetic databases . however , for word-based applications , inverted-files perform better unless complex-queries are an important issue . this index sees the text as one long string . each position in the text is considered as a text suffix (i.e. , a string that goes from that text position to the end of the text) . it is not difficult to see that two suffixes starting at different positions are lexicographically different (assume that a character smaller than all the rest is placed at the end of the text) . each suffix is thus uniquely identified by its position . not all text positions need to be indexed . index points are selected from the text , which point to the beginning of the text positions which will be retrievable . for instance , it is possible to index only word beginnings to have a functionality similar to inverted-indices . those elements which are not index points are not retrievable (as in an inverted-index it is not possible to retrieve the middle of a word) . figure 8.5 illustrates this . structure in essence , a suffix-tree is a trie data-structure built over all the suffixes of the text . the pointers to the suffixes are stored at the leaf nodes . to improve space-utilization , this trie is compacted into a patricia-tree . this involves compressing unary paths , i.e. paths where each node has just one child . an indication of the next character position to consider is stored at the nodes which root a compressed path . once unary paths are not present the tree has o (n) nodes instead of the worst-case o (n2) of the trie (see figure 8.6) . 200 indexing and searching this is a text . a text has many words . words are made from letters . text text . a text has many words . words are made from letters . text has many words . words are made from letters . many words . words are made from letters . words . words are made from letters . words are made from letters . made from letters . letters . suffixes figure 8.5 the sample text with the index points-of-interest marked . below , the suffixes corresponding to those index points . i 6 9 11 17 19 24 28 33 40 46 50 55 60 this is a text . a text has many words . words are made from letters . suffix-trie suffix-tree text figure 8.6 the suffix-trie and suffix-tree for the sample text . the problem with this structure is its space . depending on the implementation , each node of the trie takes 12 to 24 bytes , and therefore even if only word beginnings are indexed , a space-overhead of 120 % to 240 % over the text size is produced . suffix-arrays provide essentially the same functionality as suffix-trees with much less space requirements . if the leaves of the suffix-tree are traversed in left-to-right order (top to bottom in our figures) , all the suffixes of the text are retrieved in lexicographical order . a suffix-array is simply an array containing all the pointers to the text suffixes listed in lexicographical order , as shown in figure 8,7 . since they store one pointer per indexed suffix , the space requirements other indices for text 201 1 6 9 11 17 19 24 28 33 40 46 50 55 60 this is a text . a text has many words . words are made from letters . text i 60 i 50 j 28 i 19 i 11 i 40 i 33 i suffix-array figure 8.7 the suffix-array for the sample text . 1 6 9 11 17 19 24 28 33 40 46 50 55 60 this is a text . a text has many words . words are made from letters . text fiett | / 1 text | / | word i , \ supra-lndex y . y ... 60 i 50 1 28 19 1 11 i 40 1 33 1 suffix-array figure 8.8 a supra-index over our suffix-array . one out of three entries are sampled , keeping their first four characters . the pointers (arrows) are in fact unnecessary . are almost the same as those for inverted-indices (disregarding compression techniques) , i.e. close to 40 % overhead over the text size . suffix-arrays are designed to allow binary searches done by comparing the contents of each pointer . if the suffix-array is large (the usual case) , this binary-search can perform poorly because of the number of random disk accesses . to remedy this situation , the use of supra-indices over the suffix-array has been proposed . the simplest supra-index is no more than a sampling of one out of b suffix-array entries , where for each sample the first # suffix characters are stored in the supra-index . this supra-index is then used as a first step of the search to reduce external accesses . figure 8.8 shows an example . this supra-index does not in fact need to take samples at fixed intervals , nor to take samples of the same length . for word-indexing suffix-arrays it has been suggested that a new sample could be taken each time the first word of the suffix changes , and to store the word instead of i characters . this is exactly the same as having a vocabulary of the text plus pointers to the array . in fact , the only important difference between this structure and an inverted-index is that the occurrences of each word in an inverted-index are sorted by text position , while in a suffix-array they are sorted lexicographically by the text following the word . figure 8.9 illustrates this relationship . the extra space requirements of supra-indices are modest . in particular , it is clear that the space requirements of the suffix-array with a vocabulary supra-index are exactly the same as for inverted-indices (except for compression , as we see later) . 202 indexing and searching 1 6 9 11 17 19 24 28 33 40 46 50 55 60 this is a text . a text has many words . words are made from letters . text letters \ made | i many / text words vocabulary supra-lndex 33 i suffix-array 33 40 inverted list figure 8.9 relationship between our inverted list and suffix-array with vocabulary supra-index . searching if a suffix-tree on the text can be afforded , many basic patterns such as words , prefixes , and phrases can be searched in o (m) time by a simple trie-search . however , suffix-trees are not practical for large texts , as explained . suffix-arrays , on the other hand , can perform the same search operations in o (logn) time by doing a binary-search instead of a trie-search . this is achieved as follows : the search-pattern originates two ` limiting patterns5 pi and p2 , so that we want any suffix s such that pi lt ; s lt ; iv we binary-search both limiting patterns in the suffix-array . then , all the elements lying between both positions point to exactly those suffixes that start like the original pattern (i.e. , to the pattern positions in the text) . for instance , in our example of figure 8.9 , in order to find the word ` text1 we search , for ` text ' and ktexu \ obtaining the portion of the array that contains the pointers 19 and 11 . ail these queries retrieve a subtree of the suffix-tree or an interval of the suffix-array . the results have to be collected later , which may imply sorting them in ascending text order . this is a complication of suffix-trees or arrays with respect to inverted-indices . simple-phrase searching is a good case for these indices . a simple-phrase of words can be searched as if it was a simple pattern . this is because the suffix tree/array sorts with respect to the complete suffixes and not only their first word . a proximity-search , on the other hand , has to be solved element-wise . the matches for each element must be collected and sorted and then they have to be intersected as for inverted-files . the binary search performed on suffix-arrays , unfortunately , is done on disk , where the accesses to (random) text positions force a seek operation which spans the disk tracks containing the text . since a random seek is o (n) in ` size , this makes the search-cost o (n logn) time . supra-indices are used as a first step in any binary-search operation to alleviate this problem . to avoid performing o (log n) random accesses to the ivxt on disk (and to the suffix-array on disk) , the search starts in the supra-index , which usually fits in main-memory (text samples other indices for text 203 included) . after this search is completed , the suffix-array block which is between the two selected samples is brought into memory and the binary search is completed (performing random accesses to the text on disk) . this reduces disk search times to close to 25 % of the original time . modified binary-search techniques that sacrifice the exact partition in the middle of the array taking into account the current disk head position allow a further reduction from 40 % to 60 % . search times in a 250 mb text in our reference machine are close to 1 second for a simple word or phrase , while the part corresponding to the accesses to the text sums up 0.6 seconds . the use of supra-indices should put the total time close to 0.3 seconds . note that the times , although high for simple words , do not degrade for long phrases as with inverted-indices . construction in main-memory a suffix-tree for a text of n characters can be built in o (n) time . the algorithm , however , performs poorly if the suffix-tree does not fit in main-memory , which is especially stringent because of the large space requirements of the suffix-trees . we do not cover the linear algorithm here because it is quite complex and only of theoretical interest . we concentrate on direct suffix-array construction . since the suffix-array is no more than the set of pointers lexicographically sorted , the pointers are collected in ascending text order and then just sorted by the text they point to . note that in order to compare two suffix-array entries the corresponding text positions must be accessed . these accesses are basically random . hence , both the suffix-array and the text must be in main-memory . this algorithm costs o (n log n) string comparisons . an algorithm to build the suffix-array in o (nlogn) character comparisons follows . all the suffixes are bucket-sorted in o (n) time according to the first letter only . then , each bucket is bucket-sorted again , now according to their first two letters . at iteration i , the suffixes begin already sorted by their 22 '' `` 1 first letters and end up sorted by their first 2 % letters . as at each iteration the total cost of all the bucket sorts is o (n) , the total time is o (nlogn) , and the average is o (n log log n) (since o (logn) comparisons are necessary on average to distinguish two suffixes of a text) . this algorithm accesses the text only in the first stage (bucket-sort for the first letter) . in order to sort the strings in the i-th iteration , notice that since all suffixes are sorted by their first 2i ~ `` 1 letters , to sort the text positions to ... and il , in the suffix-array (assuming that they are in the same bucket , i.e. , they share their first 2i ~ 1 letters) , it is enough to determine the relative order between text positions ta +2 * ~ i and t ^ * -1 m the current stage of the search . this can be done in constant-time by storing the reverse permutation . we do not enter here into further detail . construction of suffix-arrays for large texts there is still the problem that large text databases will not fit in main-memory . it could be possible to apply an external-memory-sorting algorithm . however , 204 indexing and searching each comparison involves accessing the text at random positions on the disk . this will severely degrade the performance of the sorting process . we explain an algorithm especially designed for large texts . split the text into blocks that can be sorted in main-memory . then , for each block , build its suffix-array in main-memory and merge it with the rest of the array already built for the previous text . that is : ï build the suffix-array for the first block , ï build the suffix-array for the second block , ï merge both suffix-arrays , ï build the suffix-array for the third block , ï merge the new suffix-array with the previous one , ï build the suffix-array for the fourth block , ï merge the new suffix-array with the previous one , ï ... and so on . the difficult part is how to merge a large suffix-array (already built) with the small suffix-array (just built) . the merge needs to compare text positions which are spread in a large text , so the problem persists . the solution is to first determine how many elements of the large array are to be placed between each pair of elements in the small array , and later use that information to merge the arrays without accessing the text . hence , the information that we need is how many suffixes of the large text lie between each pair of positions of the small suffix-array . we compute counters that store this information . the counters are computed without using the large suffix-array . the text corresponding to the large array is sequentially read into main-memory . each suffix of that text is searched in the small suffix-array (in main-memory) . once we find the inter-element position where the suffix lies , we just increment the appropriate counter . figure 8.10 illustrates this process . we analyze this algorithm now . if there is o (m) main-memory to index , then there will be o (nfal) text blocks . each block is merged against an array of size o (n) , where all the o (n) suffixes of the large text are binary searched in the small suffix-array . this gives a total cpu complexity of o (n2 log (m) / m) . notice that this same algorithm can be used for index-maintenance . if a new text of size n ' is added to the database , it can be split into blocks as before and merged block-wise into the current suffix-array . this will take o (nn ' \ og {m) / m) . to delete some text it suffices to perform an o (n) pass over the array eliminating all the text positions which lie in the deleted areas . as can be seen , the construction process is in practice more costly for suffix-arrays than for inverted-files . the construction of the supra-index consists of a fast final sequential pass over the suffix-array . indexing times for 250 mb of text are close to 0.8 mb/niin on the reference machine . this is five to ten times slower than the construction of inverted-indices . other indices for text 205 (a) small text 1 small suffix-array (b) small text 1 small suffix-array r t counters long text (c) small text small suffix-array r counters long suffix-array final suffix-array figure 8.10 a step of the suffix-array construction for large texts : (a) the local suffix-array is built , (b) the counters are computed , (c) the suffix-arrays are merged .