 12.3    A Generic Multimedia Indexing Approach To illustrate the basic idea, we shall focus on 'whole match' queries.  For such queries the problem is defined as follows: ï  We have a collection of A" objects: Oi, O2, ..., O4\-. ï  The distance/dissimilarity between two objects (Oi^Oj) is given by the function T)(Ot,O3), which can be implemented as a (possibly, slow) pro-grain. ï   The user specifies a query object Q* and a tolerance e. A GENERIC MULTIMEDIA INDEXING APPROACH        349 Our goal is to find the objects in the collection that are within distance e from the query object. An obvious solution is to apply sequential scanning: For each and every object Oi (1 lt; i lt; JV), we can compute its distance from Q and report the objects with distance Tgt;(Q, Oi) lt; e. However, sequential scanning may be slow, for two reasons: (1)  The distance computation might be expensive. For example, as discussed in Chapter 8, the editing distance in DNA strings requires a dynamic programming algorithm, which grows like the product of the string lengths (typically, in the hundreds or thousands, for DNA databases). (2)  The database size N might be huge. Thus, we are looking for a faster alternative. The GEMINI (GEneric Multimedia object INdexIng) approach we present next, is based on two ideas, each of which tries to avoid each of the two disadvantages of sequential scanning: Æ a 'quick-and-dirty'  test,  to discard quickly the vast majority of nonqualifying objects (possibly, allowing some false alarms); Æ the use of spatial access methods, to achieve faster-than-sequential searching. The case is best illustrated with an example. Consider a database of time series, such as yearly stock price movements, with one price per day. Assume that the distance function between two such series S and Q is the Euclidean distance V(S,Q) = where S[i] stands for the value of stock S on the z-th day. Clearly, computing the distance of two stocks will take 365 subtractions and 365 squarings in our example. The idea behind the quick-and-dirty test is to characterize a sequence with a single number, which will help us discard many non-qualifying sequences. Such a number could be, e.g., the average stock price over the year. Clearly, if two stocks differ in their averages by a large margin, it is impossible that they will be similar. The converse is not true, which is exactly the reason we may have false alarms. Numbers that contain some information about a sequence (or a multimedia object, in general), will be referred to as 'features for the rest of this chapter. Using a good feature (like the 'average,' in the stock prices example), we can have a quick test, which will discard many stocks, with a single numerical comparison for each sequence (a big gain over the 365 subtractions and squarings that the original distance function requires). If using one feature is good, using two or more features might be even better, because they may reduce the number of false alarms (at the cost of 350        MULTIMEDIA IR: INDEXING AND SEARCHING making the quick-and-ciirty test a bit more elaborate and expensive). In our stock prices example, additional features might be, e.g., the standard deviation, or, even better, some of the discrete Fourier transform (DFT) coefficients, as we shall see in section 12.4. The end result of using / features for each of our objects is that we can map each object into a point in /-dimensional space. We shall refer to this mapping as T() (for T'eature): Definition     Let JF() be the mapping of objects to f-dimensional points, that is, T(O) will be the f-D point that corresponds to object O. This mapping provides the key to improve on the second drawback of sequential scanning: by organizing these f-D points into a spatial access method, we can cluster them in a hierarchical structure, like the R*-trees. Upon a query, we can exploit the i?*-tree, to prune out large portions of the database that are not promising. Thus, we do not even have to do the quick-and-dirty test on all of the f-D points! Figure 12.3 illustrates the basic idea: Objects (e.g., time series that are 365 points long) are mapped into 2D points (e.g., using the average and the standard deviation as features). Consider the 'whole match' query that requires all the objects that are similar to Sn within tolerance e: this query becomes an f-D sphere in feature space, centered on the image J-(Sn) of Sn. Such queries on multidimensional points is exactly what R-trees and other SAMs are designed to answer efficiently. More specifically, the search algorithm for a wThole match query is as follows: Feature2 /'   \ / 365 I   ,                                                                         .'                          Feature 1 I                                    365 Figure 12.3    Illustration of the basic idea: a database of sequences S\.....S.v; each sequence is mapped to a point in feature space; a query with tolerance s becomes a sphere of radius 5. A GENERIC MULTIMEDIA INDEXING APPROACH        351 Algorithm 1 Search: (1)  Map the query object Q into a point F(Q) in feature space. (2)  Using a spatial access method, retrieve all points within the desired tolerance e fromF(Q). (3)  Retrieve the corresponding objects, compute their actual distance from Q and discard the false alarms. Intuitively, the method has the potential to relieve both problems of the sequential scan, presumably resulting in much faster searches. The only step that we have to be careful with is that the mapping !F() from objects to /-D points does not distort the distances. Let V{) be the distance function of two objects, and Vfeature() be the (say, Euclidean) distance of the corresponding feature vectors. Ideally, the mapping should preserve the distances exactly, in which case the SAM will have neither false alarms nor false dismissals. However, requiring perfect distance preservation might be difficult. For example, it is not obvious which features we have to use to match the editing distance between two DNA strings. Even if the features are obvious, there might be practical problems: for example, in the stock price example, we could treat every sequence as a 365-dimensional vector; although in theory a SAM can support an arbitrary number of dimensions, in practice they all suffer from the 'dimensionality curse,' as discussed earlier. The crucial observation is that we can guarantee that there will be no false dismissals if the distance in feature space matches or underestimates the distance between two objects. Intuitively, this means that our mapping T() from objects to points should make things look closer (i.e., it should be a contractive mapping). Mathematically, let O\ and O2 be two objects (e.g., same-length sequences) with distance function V() (e.g., the Euclidean distance) and F(O\), F{02) be their feature vectors (e.g., their first few Fourier coefficients), with distance function Vfeaiure() (e.g., the Euclidean distance, again). Then we have: Lemma 12.1 (Lower Bounding) To guarantee no false dismissals for whole-match queries, the feature extraction function P() should satisfy the following formula: VfeatUre{HOi),F(O2)) lt; V{OUO2)                                            (12.3) As proved in [249], lower-bounding the distance works correctly for range queries.   Will it work for the other queries of interest, like "all pairs" and 'nearest neighbor' ones? The answer is affirmative in both cases. An "all pairs* query can easily be handled by a "spatial join" on the points of the feature space: using a similar reasoning as before, we see that the resulting set of pairs will be a superset of the qualifying pairs. For the nearest neighbor query, the following algorithm guarantees no false dismissals: (1) find the point T{P) that is the 352        MULTIMEDIA IR: INDEXING AND SEARCHING nearest neighbor to the query point !F(Q), (2) issue a range query, with query object Q and radius e = U(Q,P) (i.e., the actual distance between the query object Q and data object P). In conclusion, the GEMINI approach to indexing multimedia objects for fast similarity searching is as follows: Algorithm 2 (GEMINI) GEneric Multimedia object INdexIng approach: (1)  Determine the distance function Tgt;() between two objects. (2)  Find one or more numerical feature-extraction functions,   to provide a 'quick-and-dirty' test. (3)  Prove that the distance in feature space lower-bounds the actual distance Tgt;(), to guarantee correctness. (4)   Use a SAM (e.g., an R-tree), to store and retrieve the f-D feature vectors. The first two steps of GEMINI deserve some more discussion: the first step involves a domain expert. The methodology focuses on the speed of search only; the quality of the results is completely relying on the distance function that the expert will provide. Thus, GEMINI will return exactly the same response set (and therefore, the same quality of output, in terms of precision-recall) that would be returned by a sequential scanning of the database; the only difference is that GEMINI will be faster. The second step of GEMINI requires intuition and imagination. It starts by trying to answer the question (referred to as the 'feature-extracting' question for the rest of this chapter): 'Feature-extracting' question: If we are allowed to use only one numerical feature to describe each data object, what should this feature be? The successful answers to the above question should meet two goals: first, they should facilitate step 3 (the distance lower-bounding), and second, they should capture most of the characteristics of the objects. We give case studies of steps 2 and 3 of the GEMINI algorithm in the following sections. The first involves ID time series, and the second focuses on 2D color images. We shall see that the philosophy of the quick-and-dirty filter, in conjunction with the lower-bounding lemma, can lead to solutions to two problems: ï  the dimensionality curse (time series) ï  the 'cross-talk' of features (color images). For each case study, we first describe the objects and the distance function, then show how to apply the lower-bounding lemma, and finally give experimental results, on real or realistic data. ONE-DIMENSIONAL TIME SERIES        353  