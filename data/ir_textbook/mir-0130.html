 7.4.5    Inverted File Compression As already discussed, an inverted file is typically composed of (a) a vector containing all the distinct words in the text collection (which is called the vocabulary) and (b) for each word in the vocabulary, a list of all documents in which that word occurs. Inverted files are widely used to index large text files. The size of an inverted file can be reduced by compressing the inverted lists. Because the list of document numbers within the inverted list is in ascending order, it can also be considered as a sequence of gaps between document numbers. Since processing is usually done sequentially starting from the beginning of the list, the original document numbers can always be recomputed through sums of the gaps. By observing that these gaps are small for frequent words and large for infrequent words, compression can be obtained by encoding small values with shorter codes. One possible coding scheme for this case is the unary cade, in which an integer x is coded as (x - 1) one bits followed by a zero bit, so the code for the Integer 3 is 110. The second column of Table 7.1 shows unary codes for integers between 1 and 10. Elias [235] presented two other variable-length coding schemes for integers. One is Elias-^ code, which represents the number j by a concatenation of two TEXT COMPRESSION 185 Gap x	Unary	Elias-7	Elias-lt;5	Golomb 6=3 1	0	0	0	00 2	10	100	1000	010 3	110	101	1001	Oil 4	1110	11000	10100	100 5	11110	11001	10101	1010 6	111110	11010	10110	1011 7	1111110	11011	10111	1100 8	11111110	1110000	11000000	11010 9	111111110	1110001	11000001	11011 10	1111111110	1110010	11000010	11100 Table 7.1    Example codes for integers. parts: (1) a unary code for 1+ LlogxJ and (2) a code of [log reJ bits that represents the value of x - 2Llos*J in binary. For x = 5, we have that 1 -h [logxj = 3 and that x - 2LlosxJ = 1. Thus, the Elias-7 code for x = 5 is generated by combining the unary code for 3 (code 110) with the 2-bits binary number for 1 (code 01) which yields the codeword 11001. Other examples of Elias-7 codes are shown in Table 7.1. The other coding scheme introduced by Elias is the Elias-5 code, which represents the prefix indicating the number of binary bits by the Elias-7 code rather than the unary code. For x = 5, the first part is then 101 instead of 110. Thus, the Elias-5 codeword for x = 5 is 10101. In general, the Elias-5 code for an arbitrary integer x requires 1 -f 2[loglog2xJ + [log xj bits. Table 7.1 shows other examples of Elias~lt;$ codes. In general, for small values of x the Elias-7 codes are shorter than the Elias-£ codes. However, in the limit, as x becomes large, the situation is reversed. Golomb [307] presented another run-length coding method for positive integers. The Golomb code is very effective when the probability distribution is geometric. With inverted files, the likelihood of a gap being of size x can be computed as the probability of having x - 1 non-occurrences (within consecutively numbered documents) of that particular word followed by one occurrence. If a word occurs within a document with a probability p, the probability of a gap of size x is then Pr[x\={l-pf~lp which is the geometric distribution. In this case, the model is parameterized and makes use of the actual density of pointers in the inverted file. Let N be the number of documents in the system and V be the size of the vocabulary. Then, the probability p that any randomly selected document contains any randomly 186        TEXT OPERATIONS chosen term can be estimated as number of pointers P==            N x V where the number of pointers represent the 'size' of the index. The Golomb method works as follows. For some parameter b, a gap x gt; 0 is coded as q -h 1 in unary, where q = [(x ó 1)/6J, followed by r = (x ó 1) ó q x b coded in binary, requiring either [logb] or ("log b] bits. That is, if r lt; 2 Llos £gt;j ó i then the number coded in binary requires [logfrj bits, otherwise it requires flog b] bits where the first bit is 1 and the remaining bits assume the value r ó 2'-los^~1 coded in [logb\ binary digits. For example, with b = 3 there are three possible remainders, and those are coded as 0, 10, and 11, for r = 0, r = 1, and r = 2, respectively. Similarly, for b = 5 there are five possible remainders r, 0 through 4, and these are assigned codes 00, 01, 100, 101, and 110. Then, if the value x = 9 is to be coded relative to 6 = 3, calculation yields q = 2 and r == 2, because 9-1 = 2 x 3 + 2. Thus, the encoding is 110 followed by 11. Relative to b = 5, the values calculated are q = 1 and r = 1, resulting in a code of 10 followed by 101. To operate with the Golomb compression method, it is first necessary to establish the parameter b for each term. For gap compression, an appropriate value is b ´ 0.69(Ar//t)^ where N is the total number of documents and ft is the number of documents that contain term t. Witten, Moffat and Bell [825] present a detailed study of different text collections. For all of their practical work on compression of inverted lists, they use Golomb code for the list of gaps. In this case Golomb code gives better compression than either Elias-7 or Elias-£. However, it has the disadvantage of requiring two passes to be generated, since it requires knowledge of ft, the number of documents containing term t. Moffat and Bell [572] show that the index for the 2 gigabytes TREC-3 collection, which contains 162,187,989 pointers and 894,406 distinct terms, when coded with Golomb code, occupies 132 megabytes. Considering the average number of bits per pointer, they obtained 5.73, 6.19, and 6.43 using Golomb, Elias-$, and Elias-7, respectively.  