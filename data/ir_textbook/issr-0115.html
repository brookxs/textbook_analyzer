 9.1 Introduction to Text Search Techniques  The basic concept of a text scanning system is the ability for one or more users to enter queries, and the text to be searched is accessed and compared to the query terms. When all of the text has been accessed, the query is complete. One advantage of this type architecture is that as soon as an item is identified as satisfying a query, the results can be presented to the user for retrieval. Figure 9.1 provides a diagram of a text streaming search system. The database contains the full text of the items. The term detector is the special hardware/software that 222  Chapter 9  contains all of the terms being searched for and in some systems the logic between the items. It will input the text and detect the existence of the search terms. It will output to the query resolver the detected terms to allow for final logical processing of a query against an item. The query resolver performs two functions. It will accept search statements from the users, extract the logic and search terms and pass the search terms to the detector. It also accepts results from the detector and determines which queries are satisfied by the             gt; 0 gt; 0 n   \ r  Term Detector Query Resolver  User In   r              Figure 9.1  Text Streaming Architecture  item and possibily the weight associated with hit. The Query Resolver will pass information to the user interface that will be continually updating search status to the user and on request retrieve any items that satisfy the user search statement. The process is focused on finding at least one or all occurrences of a pattern of text (query term) in a text stream. It is assumed that the same alhabet is used in both situations (although in foreign language streamers different encodings may have to be available for items from the same language such as in cryllic). The worst case search for a pattern of m characters in a string of n characters is at least n - m + 1 or a magnitude of O(ri) (Rivest-77). Some of the original brute force methods could require O(n*m) symbol comparisons (Sedgewick-88). More recent improvements have reduced the time to O(´ + m).  In the case of hardware search machines, multiple parallel search machines (term detectors) may work against the same data stream allowing for more queries or against different data streams reducing the time to access the complete database. In software systems, multiple detectors may execute at the same time.  There are two approaches to the data stream. In the first approach the complete database is being sent to the detector(s) functioning as a search of the database. In the second approach random retrieved items are being passed to the detectors. In this second case the idea is to perform an index search of the database and let the text streamer perform additional search logic that is not satisfied by the index search (Bird-78, Hollar-79). Examples of limits of index searches are: Text Search Algorithms                                                                            223  search for stop words  search for exact matches when steming is performed  search for terms that contain both leading and trailing "don't cares"  search for symbols that are on the interword symbol list (e.g., ",;)  The major disadvantage of basing the search on streaming the text is the dependency of the search on the slowest module in the computer (the I/O module). Inversions/indexes gain their speed by minimizing the amount of data to be retrieved and provide the best ratio between the total number of items delivered to the user versus the total number of items retrieved in response to a query. But unlike inversion systems that can require storage overheads of 50% to 300%, of the original databases (BIRD-78), the full text search function does not require any additional storage overhead. There is also the advantage where hits may be returned to the user as soon as found. Typically in an index system, the complete query must be processed before any hits are determined or available. Streaming systems also provide a very accurate estmate of current search status and time to complete the query. Inversions/indexes also encounter problems in fuzzy searches (m of n characters) and imbedded string query terms (i.e., leading and trailing "don't care", see Chapter 2). It is difficult to locate all the possibe index values short of searching the complete dictionary of possible terms. Most streaming algorithms will locate imbedded query terms and some algorithms and hardware search units will also perform fuzzy searches. Use of special hardware text serarch units insures a scalable environment where performance bottlenecks can be overcome by adding additional search units to work in parallel of of the data being streamed.  Many of the hardware and software text searchers use finite state automata as a basis for their algorithms. A finite state automata is a logical machine that is composed of five elements:  I - a set of input symbols from the aphabet supported by the automata S - a set of possible states  P - a set of productions that define the next state based upon the current state and  input symbol  So - a special state called the initial state SF - a set of one or more final states from the set S  A finite state automata is represented by a directed graph consisting of a series of nodes (states) and edges between nodes represented as transitions defined by the set of productions.   The symbol(s) associated with each edge defines the inputs that 224  Chapter 9  allow a transition from one node Si to another node Sj. Figure 9.2a shows a finite state automata that will identify the character string CPU in any input stream. The automata is defined by the the automata definition in Figure 9.2b  I = set of all alphabetic characters S = set {So, Si S2 S3) P = set{S0-ªS, if I = C  50 -gt; So if I * C S, -gt; S2 if I = P S,-gt;SoifI*{P, C}  51  -gt;Si if I = C S2-gt;S3ifI = U S2-gt;S! if I = C S2-ªSoin*{C, U}  }  So = { So } SF = { S3 }  Figure 9.2b Automata Definition /C, U  = C  Figure 9.2a Finite State Automata  The automata remains in the initial state until it has an input symbol of "C" which moves it to state Sj. It will remain in that state as long as it receives "C"s as input. If it receives a "P" it will move to S2. If it receives anything else it falls back to the initial state. Once in state S2 it will either go to the final state if "U" is the next symbol, go to Si if a "C" is received or go back to the initial state So if anything else is received.  It is possible to represent the productions by a table with the states as the rows and the input symbols that cause state transitions as each column. The states are representing the current state and the values in the table are the next state given the particular input symbol.  