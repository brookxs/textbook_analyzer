<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<html>
 <head> 
  <title>Processing Boolean queries</title> 
  <meta name="description" content="Processing Boolean queries" /> 
  <meta name="keywords" content="irbook" /> 
  <meta name="resource-type" content="document" /> 
  <meta name="distribution" content="global" /> 
  <meta name="Generator" content="LaTeX2HTML v2002-2-1" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <link rel="STYLESHEET" href="irbook.css" /> 
  <link rel="next" href="the-extended-boolean-model-versus-ranked-retrieval-1.html" /> 
  <link rel="previous" href="a-first-take-at-building-an-inverted-index-1.html" /> 
  <link rel="up" href="boolean-retrieval-1.html" /> 
  <link rel="next" href="the-extended-boolean-model-versus-ranked-retrieval-1.html" /> 
 </head> 
 <body> 
  <!--Navigation Panel--> 
  <a name="tex2html964" href="the-extended-boolean-model-versus-ranked-retrieval-1.html"> <img width="37" height="24" align="BOTTOM" border="0" alt="next" src="http://nlp.stanford.edu/IR-book/html/icons/next.png" /></a> 
  <a name="tex2html958" href="boolean-retrieval-1.html"> <img width="26" height="24" align="BOTTOM" border="0" alt="up" src="http://nlp.stanford.edu/IR-book/html/icons/up.png" /></a> 
  <a name="tex2html952" href="a-first-take-at-building-an-inverted-index-1.html"> <img width="63" height="24" align="BOTTOM" border="0" alt="previous" src="http://nlp.stanford.edu/IR-book/html/icons/prev.png" /></a> 
  <a name="tex2html960" href="contents-1.html"> <img width="65" height="24" align="BOTTOM" border="0" alt="contents" src="http://nlp.stanford.edu/IR-book/html/icons/contents.png" /></a> 
  <a name="tex2html962" href="index-1.html"> <img width="43" height="24" align="BOTTOM" border="0" alt="index" src="http://nlp.stanford.edu/IR-book/html/icons/index.png" /></a> 
  <br /> 
  <b> Next:</b> 
  <a name="tex2html965" href="the-extended-boolean-model-versus-ranked-retrieval-1.html">The extended Boolean model</a> 
  <b> Up:</b> 
  <a name="tex2html959" href="boolean-retrieval-1.html">Boolean retrieval</a> 
  <b> Previous:</b> 
  <a name="tex2html953" href="a-first-take-at-building-an-inverted-index-1.html">A first take at</a> &nbsp; 
  <b> <a name="tex2html961" href="contents-1.html">Contents</a></b> &nbsp; 
  <b> <a name="tex2html963" href="index-1.html">Index</a></b> 
  <br /> 
  <br /> 
  <!--End of Navigation Panel--> 
  <h1><a name="SECTION00630000000000000000"></a><a name="sec:boolean-queries"></a> <a name="p:boolean-queries"></a> <a name="sec:postingsintersection"></a> <a name="p:postingsintersection"></a> <br /> Processing Boolean queries </h1> 
  <p> How do we process a query using an inverted index and the basic Boolean retrieval model? Consider processing the <a name="1549"></a><a name="1244"></a> <i>simple conjunctive query</i> : <br /> <img width="189" height="16" align="BOTTOM" border="0" src="img55.png" alt="\begin{example}
\term{Brutus} \oper{AND} \term{Calpurnia}
\end{example}" /> <br /> over the inverted index partially shown in Figure&nbsp;<a href="an-example-information-retrieval-problem-1.html#fig:invertedindex-picture">1.3</a> (page&nbsp;<a href="an-example-information-retrieval-problem-1.html#p:invertedindex-picture"><img align="BOTTOM" border="1" alt="[*]" src="http://nlp.stanford.edu/IR-book/html/icons/crossref.png" /></a>). We: </p> 
  <ol> 
   <li>Locate Brutus in the Dictionary </li> 
   <li>Retrieve its postings </li> 
   <li>Locate Calpurnia in the Dictionary </li> 
   <li>Retrieve its postings </li> 
   <li>Intersect the two postings lists, as shown in Figure <a href="#fig:postingsmerge">1.5</a> . </li> 
  </ol> The 
  <a name="1258"></a> 
  <i>intersection </i> is the crucial one: we need to efficiently intersect postings lists so as to be able to quickly find documents that contain both terms. (This operation is sometimes referred to as 
  <a name="1260"></a> 
  <i>merging</i> postings lists: this slightly counterintuitive name reflects using the term 
  <a name="1262"></a> 
  <i>merge algorithm</i> for a general family of algorithms that combine multiple sorted lists by interleaved advancing of pointers through each; here we are merging the lists with a logical AND operation.) 
  <p> </p> 
  <div align="CENTER"> 
   <a name="fig:postingsmerge"></a> 
   <a name="p:postingsmerge"></a> 
   <a name="1550"></a> 
   <table> 
    <caption align="BOTTOM"> 
     <strong>Figure:</strong> Intersecting the postings lists for Brutus and Calpurnia from Figure 
     <a href="an-example-information-retrieval-problem-1.html#fig:invertedindex-picture">1.3</a> . 
    </caption> 
    <tbody> 
     <tr> 
      <td><img width="474" height="89" border="0" src="img56.png" alt="\begin{figure}\begin{tabular}{lll}
Brutus &amp; $\longrightarrow$\ &amp;
\framebox{1}$\r...
...rightarrow$\ &amp; \framebox{2}$\rightarrow$\framebox{31}
\end{tabular}
\end{figure}" /></td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <p> </p> 
  <div align="CENTER"> 
   <a name="fig:postings-merge-algorithm"></a> 
   <a name="p:postings-merge-algorithm"></a> 
   <a name="1305"></a> 
   <table> 
    <caption align="BOTTOM"> 
     <strong>Figure 1.6:</strong> Algorithm for the intersection of two postings lists 
     <img width="20" height="32" align="MIDDLE" border="0" src="img1.png" alt="$p_1$" /> and 
     <img width="20" height="32" align="MIDDLE" border="0" src="img2.png" alt="$p_2$" />. 
    </caption> 
    <tbody> 
     <tr> 
      <td><img width="292" height="203" border="0" src="img57.png" alt="\begin{figure}\begin{algorithm}{Intersect}{p_1, p_2}
answer \= \langle\;\rangle ...
..._2)
\end{IF}\end{IF}\end{WHILE} \\
\RETURN{answer}
\end{algorithm}
\end{figure}" /></td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <p> There is a simple and effective method of intersecting postings lists using the merge algorithm (see Figure <a href="#fig:postings-merge-algorithm">1.6</a> ): we maintain pointers into both lists and walk through the two postings lists simultaneously, in time linear in the total number of postings entries. At each step, we compare the docID pointed to by both pointers. If they are the same, we put that docID in the results list, and advance both pointers. Otherwise we advance the pointer pointing to the smaller docID. If the lengths of the postings lists are <img width="12" height="32" align="MIDDLE" border="0" src="img58.png" alt="$x$" /> and <img width="12" height="32" align="MIDDLE" border="0" src="img59.png" alt="$y$" />, the intersection takes <img width="66" height="33" align="MIDDLE" border="0" src="img60.png" alt="$O(x+y)$" /> operations. Formally, the complexity of querying is <img width="44" height="33" align="MIDDLE" border="0" src="img61.png" alt="$\Theta(N)$" />,<a name="Theta-notation"></a>where <img width="17" height="32" align="MIDDLE" border="0" src="img62.png" alt="$N$" /> is the number of documents in the collection.<a name="tex2html12" href="footnode.html#foot1552"><sup><img align="BOTTOM" border="1" alt="[*]" src="http://nlp.stanford.edu/IR-book/html/icons/footnote.png" /></sup></a>Our indexing methods gain us just a constant, not a difference in <img width="17" height="32" align="MIDDLE" border="0" src="img65.png" alt="$\Theta$" /> time complexity compared to a linear scan, but in practice the constant is huge. To use this algorithm, it is crucial that postings be sorted by a single global ordering. Using a numeric sort by docID is one simple way to achieve this. </p> 
  <p> We can extend the intersection operation to process more complicated queries like: <br /> <img width="306" height="16" align="BOTTOM" border="0" src="img66.png" alt="\begin{example}
{(\term{Brutus} \oper{OR} \term{Caesar})} \oper{AND} \oper{NOT} \term{Calpurnia}
\end{example}" /> <br /> <a name="1320"></a> <i>Query optimization</i> is the process of selecting how to organize the work of answering a query so that the least total amount of work needs to be done by the system. A major element of this for Boolean queries is the order in which postings lists are accessed. What is the best order for query processing? Consider a query that is an AND of <img width="10" height="32" align="MIDDLE" border="0" src="img67.png" alt="$t$" /> terms, for instance: <br /> <img width="274" height="16" align="BOTTOM" border="0" src="img68.png" alt="\begin{example}
\term{Brutus} \oper{AND} \term{Caesar} \oper{AND} \term{Calpurnia}
\end{example}" /> <br /> For each of the <img width="10" height="32" align="MIDDLE" border="0" src="img67.png" alt="$t$" /> terms, we need to get its postings, then AND them together. The standard heuristic is to process terms in order of increasing document frequency: if we start by intersecting the two smallest postings lists, then all intermediate results must be no bigger than the smallest postings list, and we are therefore likely to do the least amount of total work. So, for the postings lists in Figure&nbsp;<a href="an-example-information-retrieval-problem-1.html#fig:invertedindex-picture">1.3</a> (page&nbsp;<a href="an-example-information-retrieval-problem-1.html#p:invertedindex-picture"><img align="BOTTOM" border="1" alt="[*]" src="http://nlp.stanford.edu/IR-book/html/icons/crossref.png" /></a>), we execute the above query as: <br /> <img width="286" height="16" align="BOTTOM" border="0" src="img69.png" alt="\begin{example}
{(\term{Calpurnia} \oper{AND} \term{Brutus})} \oper{AND} \term{Caesar}
\end{example}" /> <br /> This is a first justification for keeping the frequency of terms in the dictionary: it allows us to make this ordering decision based on in-memory data before accessing any postings list. </p> 
  <p> Consider now the optimization of more general queries, such as: <br /> <img width="469" height="16" align="BOTTOM" border="0" src="img70.png" alt="\begin{example}
{(\term{madding} \oper{OR} \term{crowd})} \oper{AND} (\term{igno...
...} \term{strife}) \oper{AND} (\term{killed} \oper{OR} \term{slain})
\end{example}" /> <br /> As before, we will get the frequencies for all terms, and we can then (conservatively) estimate the size of each OR by the sum of the frequencies of its disjuncts. We can then process the query in increasing order of the size of each disjunctive term. </p> 
  <p> </p> 
  <div align="CENTER"> 
   <a name="fig:asymmetric-merge-algorithm"></a> 
   <a name="p:asymmetric-merge-algorithm"></a> 
   <a name="1365"></a> 
   <table> 
    <caption align="BOTTOM"> 
     <strong>Figure 1.7:</strong> Algorithm for conjunctive queries that returns the set of documents containing each term in the input list of terms. 
    </caption> 
    <tbody> 
     <tr> 
      <td><img width="413" height="146" border="0" src="img71.png" alt="\begin{figure}\begin{algorithm}{Intersect}{\langle t_1, \ldots, t_n \rangle}
ter...
...erms \= rest(terms)
\end{WHILE} \\
\RETURN{result}
\end{algorithm}
\end{figure}" /></td> 
     </tr> 
    </tbody> 
   </table> 
  </div> 
  <p> For arbitrary Boolean queries, we have to evaluate and temporarily store the answers for intermediate expressions in a complex expression. However, in many circumstances, either because of the nature of the query language, or just because this is the most common type of query that users submit, a query is purely conjunctive. In this case, rather than viewing merging postings lists as a function with two inputs and a distinct output, it is more efficient to intersect each retrieved postings list with the current intermediate result in memory, where we initialize the intermediate result by loading the postings list of the least frequent term. This algorithm is shown in Figure <a href="#fig:asymmetric-merge-algorithm">1.7</a> . The intersection operation is then asymmetric: the intermediate results list is in memory while the list it is being intersected with is being read from disk. Moreover the intermediate results list is always at least as short as the other list, and in many cases it is orders of magnitude shorter. The postings intersection can still be done by the algorithm in Figure <a href="#fig:postings-merge-algorithm">1.6</a> , but when the difference between the list lengths is very large, opportunities to use alternative techniques open up. The intersection can be calculated in place by destructively modifying or marking invalid items in the intermediate results list. Or the intersection can be done as a sequence of binary searches in the long postings lists for each posting in the intermediate results list. Another possibility is to store the long postings list as a hashtable, so that membership of an intermediate result item can be calculated in constant rather than linear or log time. However, such alternative techniques are difficult to combine with postings list compression of the sort discussed in Chapter <a href="index-compression-1.html#ch:icompress">5</a> . Moreover, standard postings list intersection operations remain necessary when both terms of a query are very common. </p> 
  <p> <b>Exercises.</b> </p> 
  <ul> 
   <li>For the queries below, can we still run through the intersection in time <img width="66" height="33" align="MIDDLE" border="0" src="img60.png" alt="$O(x+y)$" />, where <img width="12" height="32" align="MIDDLE" border="0" src="img58.png" alt="$x$" /> and <img width="12" height="32" align="MIDDLE" border="0" src="img59.png" alt="$y$" /> are the lengths of the postings lists for Brutus and Caesar? If not, what can we achieve? 
    <ol> 
     <li>Brutus and not Caesar </li> 
     <li>Brutus or not Caesar </li> 
    </ol> <p> </p></li> 
   <li><a name="ex:arbitrary-merge"></a>Extend the postings merge algorithm to arbitrary Boolean query formulas. What is its time complexity? For instance, consider: 
    <dl compact=""> 
     <dt>
       c. 
     </dt> 
     <dd>
       (Brutus OR Caesar) AND NOT (Antony OR Cleopatra) 
     </dd> 
    </dl> Can we always merge in linear time? Linear in what? Can we do better than this? <p> </p></li> 
   <li>We can use distributive laws for and and or to rewrite queries. 
    <ol> 
     <li>Show how to rewrite the query in Exercise <a href="#ex:arbitrary-merge">1.3</a> into disjunctive normal form using the distributive laws. </li> 
     <li>Would the resulting query be more or less efficiently evaluated than the original form of this query? </li> 
     <li>Is this result true in general or does it depend on the words and the contents of the document collection? </li> 
    </ol> <p> </p></li> 
   <li>Recommend a query processing order for 
    <dl compact=""> 
     <dt>
       d. 
     </dt> 
     <dd>
       (tangerine OR trees) AND (marmalade OR skies) AND (kaleidoscope OR eyes) 
     </dd> 
    </dl> given the following postings list sizes: 
    <blockquote> 
     <table cellpadding="3"> 
      <tbody> 
       <tr> 
        <th align="LEFT"><b>Term</b></th> 
        <th align="RIGHT"><b>Postings size</b></th> 
       </tr> 
       <tr> 
        <td align="LEFT">eyes</td> 
        <td align="RIGHT">213312</td> 
       </tr> 
       <tr> 
        <td align="LEFT">kaleidoscope</td> 
        <td align="RIGHT">87009</td> 
       </tr> 
       <tr> 
        <td align="LEFT">marmalade</td> 
        <td align="RIGHT">107913</td> 
       </tr> 
       <tr> 
        <td align="LEFT">skies</td> 
        <td align="RIGHT">271658</td> 
       </tr> 
       <tr> 
        <td align="LEFT">tangerine</td> 
        <td align="RIGHT">46653</td> 
       </tr> 
       <tr> 
        <td align="LEFT">trees</td> 
        <td align="RIGHT">316812</td> 
       </tr> 
      </tbody> 
     </table> 
    </blockquote> <p> </p></li> 
   <li>If the query is: 
    <dl compact=""> 
     <dt>
       e. 
     </dt> 
     <dd>
       friends AND romans AND (NOT countrymen) 
     </dd> 
    </dl> how could we use the frequency of countrymen in evaluating the best query evaluation order? In particular, propose a way of handling negation in determining the order of query processing. <p> </p></li> 
   <li>For a conjunctive query, is processing postings lists in order of size guaranteed to be optimal? Explain why it is, or give an example where it isn't. <p> </p></li> 
   <li>Write out a postings merge algorithm, in the style of Figure&nbsp;<a href="#fig:postings-merge-algorithm">1.6</a> (page&nbsp;<a href="processing-boolean-queries-1.html#p:postings-merge-algorithm"><img align="BOTTOM" border="1" alt="[*]" src="http://nlp.stanford.edu/IR-book/html/icons/crossref.png" /></a>), for an <img width="12" height="32" align="MIDDLE" border="0" src="img58.png" alt="$x$" /> OR <img width="12" height="32" align="MIDDLE" border="0" src="img59.png" alt="$y$" /> query. <p> </p></li> 
   <li>How should the Boolean query <img width="12" height="32" align="MIDDLE" border="0" src="img58.png" alt="$x$" /> AND NOT <img width="12" height="32" align="MIDDLE" border="0" src="img59.png" alt="$y$" /> be handled? Why is naive evaluation of this query normally very expensive? Write out a postings merge algorithm that evaluates this query efficiently. <p> </p></li> 
  </ul> 
  <p> </p> 
  <hr /> 
  <!--Navigation Panel--> 
  <a name="tex2html964" href="the-extended-boolean-model-versus-ranked-retrieval-1.html"> <img width="37" height="24" align="BOTTOM" border="0" alt="next" src="http://nlp.stanford.edu/IR-book/html/icons/next.png" /></a> 
  <a name="tex2html958" href="boolean-retrieval-1.html"> <img width="26" height="24" align="BOTTOM" border="0" alt="up" src="http://nlp.stanford.edu/IR-book/html/icons/up.png" /></a> 
  <a name="tex2html952" href="a-first-take-at-building-an-inverted-index-1.html"> <img width="63" height="24" align="BOTTOM" border="0" alt="previous" src="http://nlp.stanford.edu/IR-book/html/icons/prev.png" /></a> 
  <a name="tex2html960" href="contents-1.html"> <img width="65" height="24" align="BOTTOM" border="0" alt="contents" src="http://nlp.stanford.edu/IR-book/html/icons/contents.png" /></a> 
  <a name="tex2html962" href="index-1.html"> <img width="43" height="24" align="BOTTOM" border="0" alt="index" src="http://nlp.stanford.edu/IR-book/html/icons/index.png" /></a> 
  <br /> 
  <b> Next:</b> 
  <a name="tex2html965" href="the-extended-boolean-model-versus-ranked-retrieval-1.html">The extended Boolean model</a> 
  <b> Up:</b> 
  <a name="tex2html959" href="boolean-retrieval-1.html">Boolean retrieval</a> 
  <b> Previous:</b> 
  <a name="tex2html953" href="a-first-take-at-building-an-inverted-index-1.html">A first take at</a> &nbsp; 
  <b> <a name="tex2html961" href="contents-1.html">Contents</a></b> &nbsp; 
  <b> <a name="tex2html963" href="index-1.html">Index</a></b> 
  <!--End of Navigation Panel--> 
  <address> &copy; 2008 Cambridge University Press<br />This is an automatically generated page. In case of formatting errors you may want to look at the <a href="http://informationretrieval.org">PDF edition</a> of the book.<br /> 2009-04-07 </address>  
 </body>
</html>