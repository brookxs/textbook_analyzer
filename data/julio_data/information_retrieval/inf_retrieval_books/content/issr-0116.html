 Text Search Algorithms                                                                           225  9.2         Software Text Search Algorithms  In software streaming techniques, the item to be searched is read into memory and then the algorithm is applied. Although nothing in the architecture described above prohibits software streaming from being applied to many simultaneous searches against the same item, it is more frequently used to resolve a particular search against a particular item. There are four major algorithms associated with software text search: the brute force approach, Knuth-MorrisPratt, Boyer-Moore, Shift-OR algorithm, and Rabin-Karp. Of all of the algrithms, Boyer-Moore has been the fastest requiring at most O(n + m) comparisons (Smit82). Knuth-Pratt-Morris and Boyer-Moore both require O(n) preprocessing of search strings (Knuth-77, Boyer-77, Rytter-80).  The Brute force approach is the simplest string matching algorithm. The idea is to try and match the search string against the input text. If as soon as a mismatch is detected in the cmparison process, shift the nput text one position and start the comparison process over. The expectednumber of comparisons when searching an input text string of n characters for a pattern of m characters is (Baeza-Yates-89):  Nc = -----(1-   ym)(n-m+\) + 0(1)  c√≥ 1          / c  where Nc is the expected number of comparisons and c is the size of the alphabet for the text.  The Knuth-Pratt-Morris algorithm made a major imprvement in previous algorithms in that even in the worst case it does not depend upon the length of the text pattern being searched for. The basic concept behind the algorithm is that whenever a mismatch is detected, the previousmatched characters define the number of characters that can be skipped in the input stream prior to starting the comparison process again. For example given:  Position                   12 3 4 5 6 7 8  Input Stream       = a b d ad   e f g Search Pattern     = a b d f  When the mismatch occurs in position 4 with a "f in the pattern and a "b" in the input stream, a brute force approach may shift just one position in the input text and restart the comparison. But since the first three positions of the pattern 226                                                                                                Chapter 9  matched (a b d), then shifting one position can not find an "a" because it has already been identified as a "b". The algorithm allows the comparison to jump at least the three positions associated with the recognized "a b d" . Since the mismatch on the position could be the beginning of the search string, four positions can not be skipped. To know the number of positions to jump based upon a mismatch in the search pattern, the search pattern is pre-processed to define a number of characters to be jumped for each position. The Shift Table that specifies the number of places to jump given a mismatch is shown in Figure 9.3. In the table it should be noted that the alignment is primarily based on aligning over the repeats of the letters "a" and "ab". Figure 9.4 provides an example application of the algorithm (Salton-89) where S is the search pattern and I is the input text stream.  Boyer-Moore recognized that the string algorithm could be significantly enhanced if the comparison process started at the end of the search pattern processing right to left versus the start of the search pattern. The advantage is that large jumps are possible when the mismatched character in the input stream does not exist in the search pattern which occurs frequently. This leads to two possible sources of determining how many input characters to be jumped. As in the KnuthMorris-Pratt technique any characters that have been matched in the search pattern will require an alignment with that substring. Additionally the character in the input stream that was mismatched also requires alignment with its next occurrence  Search Pattern = abcabcacab  Position in pattern pattern character length previous number of input    repeating substring characters to jump  1 a 0 1  2 b 0 1  3 c 0 2  4 a 0 4  5 b 1 5  6 c 2 6  7 a 3 3  8 c 4 3  9 a 0 8  10 b 1 8  Figure 9.3   Shift Characters Table Text Search Algorithms                                                                            227  p       1        2       3        4        5        6        7       8       9        10      11      12      13      14      15      16 Sabcabcacab  I  babcbabcabcaabca t  mismatch in position 1 shift one position  p       1       2       3       4       5       6       7       8       9        10      11      12      13      14      15      16  S    abcabcacab  1  babcbabcabcaabca  t  mismatch in position 5, no repeat pattern, skip 3 places  p       1        2       3       4        5        6        7       8        9        10      11       12      13      14      15      16  S                                  abcabcacab  I  babcbabcabcaabca  t mismatch in position 5, shift one position  p       1        2       3        4        5        6       7       8       9        10      11      12      13      14      15      16  S                                         abcabcacab  I  babcbabcabcaabca  t  mismatch in position 13, longest repeating pattern is "a b c a" thus skip 3  p       1        2        3        4        5       6       7       8       9        10      11      12      13      14      15      16  S                                                              abcabcab  I  babcbabcabcaabca  alignment after last shift  Figure 9.4 Example of Knuth-Morris-Pratt Algorithm  in the search pattern or the complete pattern can be moved. This can be defined as:  ALGOi - on a mismatch, the character in the input stream is compared to the search pattern to determine the shifting of the search pattern (number of characters in input stream to be skipped) to align the input character to a character in the search pattern.   If the character does not exist in the 228                                                                                                Chapter 9  search pattern then it is possible to shift the length of the search pattern matched to that position.  ALGO2 - on a mismatch occurs with previous matching on a substring in the input text, the matching process can jump to the repeating ocurrence in the pattern of the initially matched subpattern - thus aligning that portion of the search pattern that is in the input text.  Upon a mismatch, the comparison process can skip the MAXIMUM (ALGOi, ALGO2). Figure 9.5 gives an example of this process. In this example the search pattern is (a b d a a b) and the alphabet is (a, b, c, d, e, f) with m = 6 and c = 6.  Position 1 2 3 4 5 6 7 8 9 10 11 12 13  Input Stream f a b f a a b b d a b a b  Search Pattern  a b d a a b            t           a.    mismatch in position 4: ALGO] = 3, ALGO2 = 4, thus skip 4 places  Position 1 2 3 4 5 6 7 8 9 10 11 12 13  Input Stream f a b f a a b b d a b a b  Search Pattern      a b d a a b             t      b.   mismatch in position 9:   ALGOi = 1, ALGO2   =   4 thus skip four places  Position 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  Input Stream f a b f a a b b d a b d a a b  Search Pattern          a b d a a b  c.   new aligned search continues with a match  Figure 9.5 Boyer-Moore Algorithm  The comparison starts at the right end of the search pattern and works towards the start of the search pattern.    In the first comparison (Figure 9.5 a.) the mismatch Text Search Algorithms                                                                            229  occurs in position 4 after matching on positions 7, 6, and 5.. ALGOi wants to align the next occurrence of the input text stream mismatch character "f* which does not exist in the search pattern thus allowing for a skip of three positions. ALGO2 recognizes that the mismatch occurred after 3 previous search pattern characters had matched. Based upon the pattern stream it knows that the subpattern consisting of the first three characters (a b) repeats in the first two positions of the search pattern. Thus given a mismatch in position 4, the search pattern can be moved four places to align the subpattern consisting of the first two characters (a b) over their known occurrence in positions 6, and 7 in the input text. In the next comparison (Figure 9.5 b.) there is a mismatch in position 9. The input character that mismatched is a "d" and the fewest positions to shift to align the next occurrence of a "d" in the search pattern over it is one position. The analysis for ALGO2 is the same as before. With the next jump of four positions, the two patterns will match.  The original Boyer-Moore algorithm has been the basis for additional text search techniques. It was originally designed to support scanning for a single search string. It was expanded to handle multiple search strings on a single pass (Kowalski-83). Enhanced and simplified versions of the Boyer-Moore algorithm have been developed by may researchers (Mollier-Nielsen-84, Iyengar-80, Commentz-Walter-79, Baeza-Yates-90, Galil-79, Horspol-80).  A different approach that has similarity to n-grams and signature files defined in Chapter 4 is to divide the text into /w-character substrings, calculate a hash function (signature) value for each of the strings (Harrison-71). A hash value is calculated for the search pattern and compared to that of the text. Karp and Rabin discovered an efficient signature function to calculate these values; h(k) = k mod q, where q is a large prime number (Karp-87). The signature value for each location in the text which is based upon the value calculated for the previous location. Hashing functions do not gauranttee uniqueness. Their algorithm wll find those positions in the text of an item that have the same hash value as the search pattern. But the actual text must then be compared to ensure there is a match. Detailed implementation of the Karp-Rabin algorithm is presented by Baeza-Yates (Baeza-Yates-92). In his comparison of all of the algorithms on a search of 1000 random patterns in random text, the Horspool simplification of the Boyer-Moore algorithm showed the best execution time for patterns of any length. The major drawback of the Boyer-Moore class of algorithms is the significant preprocessing time to set up the tables. Many of these algorithms are also implemented with hardware.  Another approach based upon Knuth-Pratt-Morris uses a finite state machine to process multiple query terms (Aho-75). The pattern matching machine consists of a set of states. The machine processes the input text by successively reading in the next symbol and based upon the current state, make the state transitions while indicating matches when they occur. The machines operation is based upon three functions; GOTO (i.e., state transition), a failure function and an output function. Figure 9.6 shows the functions for the set of words HE, SHE, HIS, 230  Chapter 9  and HER. The initial state is labeled state 0. The GOTO function is a directed graph where the letter(s) on the connecting line between states (circles) specify the transition for that input given the current state. For example in Figure 9.6, if the current state is 1 and a E or I are received, then the machine will go to steates 2 and 6 respectively. The absence of an arrow or current input character that is not on a line leading from the current nore represents a failure condition. When a failure occurs, the failure function maps a state into another state (it could be to itself) to continue the search process. Certain states are defined as output states. Whenever they are reached it means one or more query terms have been matched.  (a) GOTO Function  1 2 3 4 5 6 7 8 9  0 0 0 1 2 0 3 0 3  (b) Failure Function  state              2  OUTPUT       HE  5                   7  SHE, HE        HIS  HERS  (c) OUTPUT Function Figure 9.6 Tables for Aho-Corasick Algorithm  Thus if an H has been received and the system is in state 1. If the next input symbol is an E the system moves to state 2, if an I is received then it moves to state 6, if any other letter is received, it will be an error and Failure Function (the third column in 9.6(b)) specifies the system should move to state 0 and the same input character is applied to this state. Text Search Algorithms  231  The number of characters compared is the same for both the AhoCorasick and the KMP algorithms. In the new algorithm the number of state transitions required to process a string is independent of the number of search terms and the operation to perfom the search is linear with respect to the number of characters in the input stream. The order of magnitude of the number of characters compared is equal to w* O(T) where w is a constant greater than 1 and T is the number of characters in the input string. This is a major enhancement over both Knuth-Morris-Pratt which is proportional to the number of characters in the query and Boyer-Moore which can only handle one query term.  These concepts were expanded by Baeza-Yates and Gonnet and can handle "don't care" symbols and compliment symbols (Baeza-Yates-92a). The search also handles the cases of up to k mismatches. Their approach uses a vector of m differnet states, where m is the length of the search pattern and state i gives the state of the search between the positions 1, .. . , i of the pattern and positions (j - / + 1), . . . ,y of the text where y is the current position in the text. This n effect expands the process to act like it has m simultaneous comparators working. If sy is the set of states (1 lt; i lt; m) after reading the jth character of the text. It represents the number of characters that are different in the corresponding positions between pat\9 . . . , pah and textj.i+u - √Ø √Ø , textj where pat is the search pattern and text is the text being searched. If Sg =0 then there is a perfect match. Otherwise it provides a fiizzy search capability where the search term length and the found term length are the same and the value is for the number of mismatches. For example let the search pattern be ababc (m = 5) and a segment of input text to be cbbabababcaba then figure 9.7 Shows the value for Sy_i vector. For example  Vector value     Vector Position  a b  aba  aba  a b a b  ...c   bbababal  babe  a b c  b c  b c  c a b a ...       Input Text Stream ...  1 1  0 2  3 3  0 4  Figure 9.7 Vector for Position j - I  the vector value for vector position 3 is 0 because the three pat characters aba have no matches with the corresponding three characters bab from the input text stream.  When one position in the text is advanced, the new vector is shown in Figure 9.8. 232  Chapter 9  a  a b aba aba a b a b c   bbababa  Vector value      Vector Position  babe                          0                         1  a b c                             2                         2  be                                  0                         3  be                                   4                         4  1 b c a b a ...     Input Text Stream ...  Figure 9.8 Vector for Position 7  If T(x) is a table such that Tj(x) = 0 if x = patv, otherwise T,(x) =1.   Thus everywhere that the current vector value is zero (i.e., the apttern matches), the T(x) value will be zero. Eery other location will have a T(x) value of one. Thus for example 9.7 above the T5(x) will appear (1,0,1,0,1) and for Figure 9.8 it will be (0,1,0,1,1) which is called T(new) below. It is then possible to define:  s(ij) = s(i, j-I) + Ti(textj)  If s(0, j) = 0 then the following shows the effect of moving the one position from Figure 9.7 (call old) to Figure 8 (call new):  s(l, new) = s(0, old) + T^new) = 0 + 0 = 0 s(2, new) = s(l, old) + T2(new) =1 + 1=2 s(3, new) = s(2, old) + T3(new) = 0 + 0 = 0 s(4, new) = s(3, old) + T4(new) = 3+1=4 s(5, new) = s(4, old) + T5(new) = 0+1 = 1  Because of these operations, they called the algorithm the Shift-add algorithm. To extend the technique to allow for "don't care" symbols, compliments of a character o class (i.e., matches a character that does not belong to the class), or any finite set of symbols, three possibilities will exist for any position in the pattern:  a character from the alphabet a "don't care" character (*)  a compliment of a chracter or class of characters (C) Text Search Algorithms                                                                            233  Letting m' be the total of the number of elements in each class with * assigned a value of 1 and compliments not cosidered. Let m be the size of the pattern. The pattern:  [Pp]a[a"eiou]* a [p . . .tx ... z] values each class   2   1     5    11         5 + 3  has m = 6 and m' = 18. The Shift-add algorithm is extended by modifying the table T, such that, for each position every character in the class is processed. Thus if the alhabet equals (a, b, c, d) and the pattern is:  aZgt;[ab]b[abc]  with m =5 and m" = 8. If b=l (as for string interring), the entries for th table T are:  T(a)= 11000 T(b)= 10011 T(c)= 11101 T(d) = 01101  Baeza-Yates and Gonnet describe the details of the implementation of this algorithm in the referenced paper. One advantage to this algorithm is that it can easily be implemented in a hardware solution. The Shift-add algorithm is extended by Wu and Manber to handle insertions and deletions as well as positional mismatches (Wu-92).   