 Data Structure                                                                                             93  4.6 Signature File Structure  The goal of a signature file structure is to provide a fast test to eliminate the majority of items that are not related to a query. The items that satisfy the test can either be evaluated by another search algorithm to eliminate additional false hits or delivered to the user to review. The text of the items is represented in a highly compressed form that facilitates the fast test. Because file structure is highly compressed and unordered, it requires significantly less space than an inverted file structure and new items can be concatenated to the end of the structure versus the significant inversion list update. Since items are seldom deleted from information data bases, it is typical to leave deleted items in place and mark them as deleted. Signature file search is a linear scan of the compressed version of items producing a response time linear with respect to file size.  The surrogate signature search file is created via superimposed coding (Faloutsos-85, Moders-49). The coding is based upon words in the item. The words are mapped into a "word signature." A word signature is a fixed length code with a fixed number of bits set to "1." The bit positions that are set to one are determined via a hash function of the word. The word signatures are ORed together to create the signature of an item. To avoid signatures being too dense with "l"s, a maximum number of words is specified and an item is partitioned into blocks of that size. In Figure 4.13 the block size is set at five words, the code length is 16 bits and the number of bits that are allowed to be "1" for each word is five.  TEXT: Computer Science graduate students study (assume block size is  five words) WORD                                                       Signature  Computer                                      0001   0110 0000  0110  Science                                         1001   0000 1110  0000  graduate                                        1000  0101 0100  0010  students                                        0000  0111   1000  0100  study                                            0000  0110 0110  0100  Block Signature                                          1001   0111   1110 0110  Figure 4.13 Superimposed Coding  The words in a query are mapped to their signature.    Search is accomplished by template matching on the bit positions specified by the words in the query.  The signature file can be stored as a signature with each row representing a signature block. Associated with each row is a pointer to the original text block. A design objective of a signature file system is trading off the size of the data 94                                                                                               Chapter 4  structure versus the density of the final created signatures. Longer code lengths reduce the probability of collision in hashing the words (i.e., two different words hashing to the same value). Fewer bits per code reduce the effect of a code word pattern being in the final block signature even though the word is not in the item. For example, if the signature for the word "hard" is 1000 0111 0010 0000, it incorrectly matches the block signature in Figure 4.13 (false hit). In a study by Faloutous and Christodoulakis (Faloutous-87) it was shown that if compression is applied to the final data structure, the optimum number of bits per word is one. This then takes on the appearance of a binary coded vector for each item, where each position in the vector represents the existence of a word in the item. This approach requires the maximum code length but ensures that there are not any false hits unless two words hash to the same value.  Search of the signature matrix requires O(N) search time. To reduce the search time the signature matrix is partitioned horizontally. One of the earliest techniques hashes the block signature to a specific slot. If a query has less than the number of words in a block it maps to a number of possible slots rather than just one. The number of slots decreases exponentially as the number of terms increases (Gustafson-71). Another approach maps the signatures into an index sequential file, where, for example, the first un" bits of the signature is used as the index to the block of signatures that will be compared sequentially to the query (Lee-89). Other techniques are two level signatures (Sacks-Davis-83, Sacks-Davis-88) and use of B-tree structures with similar signatures clustered at leaf nodes (Deppisch86).  Another implementation approach takes advantage of the fact that searches are performed on the columns of the signature matrix, ignoring those columns that are not indicated by hashing of any of the search terms. Thus the signature matrix may be stored in column order versus row order (Faioutsos-88, Lin-88, Roberts-79), called vertical partitioning. This is in effect storing the signature matrix using an inverted file structure. The major overhead comes from updates, since new ul"s have to be added to each inverted column representing a signature in the new item.  Signature files provide a practical solution for storing and locating information in a number of different situations. Faloutsos summarizes the environments that signature files have been applied as medium size databases, databases with low frequency of terms, WORM devices, parallel processing machines, and distributed environments (Faloutsos-92).   