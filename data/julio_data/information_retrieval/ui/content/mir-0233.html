 12.1    Introduction The problem we focus on here is the design of fast searching methods that will search a database of multimedia objects to locate objects that match a query object, exactly or approximately. Objects can be two-dimensional color images, gray-scale medical images in 2D or 3D (e.g., MRI brain scans), one-dimensional time series, digitized voice or music, video clips, etc. A typical query by content would be, e.g., 'zn a collection of color photographs, find ones with the same color distribution as a sunset photograph.' Specific applications include image databases; financial, marketing and production time series; scientific databases with vector fields; audio and video databases; DNA/Genorne databases; etc. In such databases, typical queries would be ''find companies whose stock prices move similarly," or 'find images that look like a sunset^ or cfind medical X-rays that contain something that has the texture of a tumor.'' Searching for similar patterns in such databases as the above is essential, because it helps in predictions, computer-aided medical diagnosis and teaching, hypothesis testing and, in general, in 'data mining' [8] and rule discovery. Of course, the distance of two objects has to be quantified. We rely on a domain expert to supply such a distance function Definition      Given two objects, O\ and 02, the distance (= dissimilarity) of the two objects is denoted by Tgt;(OuO2)                                                                                    (12.1) For example, if the objects are two (equal-lengt.h) time series, the distance V{) could be their Euclidean distance (the root of the sum of squared differences). Similarity queries can been classified into two categories; 345 346        MULTIMEDIA IR: INDEXING AND SEARCHING ï  Whole match Given a collection of N objects Oi, 0%,..., On and a query object Q, we want to find those data objects that are within distance s from Q. Notice that the query and the objects are of the same type: for example, if the objects are 512 x 512 gray-scale images, so is the query. ï  Sub-pattern match Here the query is allowed to specify only part of the object. Specifically, given N data objects (e.g., images) Oi, O2, ï ï ï, On, a query (sub-)object Q and a tolerance £, we want to identify the parts of the data objects that match the query.   If the objects are, e.g., 512x512 gray-scale images (like medical X-rays), in this case the query could be, e.g., a 16x16 subpattern (e.g., a typical X-ray of a tumor). Additional types of queries include the cnearest neighbors" queries (e.g., 'find the five most similar stocks to IBM's stock9) and the 'all pairs'' queries or "spatial joins' (e.g., 'report all the pairs of stocks that are within distance e from each other'). Both the above types of queries can be supported by the approach we describe next. As we shall see, we reduce the problem into searching for multi-dimensional points, which will be organized in R-trees; in this case, nearest-neighbor search can be handled with a branch-and-bound algorithm and the spatial join query can be handled with recent, highly fine-tuned algorithms, as discussed in section 12.8. Thus, we do not focus on nearest-neighbor and 'all-pairs' queries. For all the above types of queries, the ideal method should fulfill the following requirements: ï  It should be fast. Sequential scanning and distance calculation with each and every object will be too slow for large databases. ï  It should be 'correct'  In other words, it should return all the qualifying objects, without missing any (i.e., no 'false dismissals'). Notice that 'false alarms" are acceptable, since they can be discarded easily through a postprocessing step.    Of course, as we see, e.g. in Figure 12.5, we try to keep their number low (but not necessarily minimal), so that the total response time is minimized. ï  The ideal method should require a small space overhead. ï  The method should be dynamic.  It should be easy to insert, delete, and update objects. As we see next, the heart of the presented 'GEMINI* approach is to use / feature extraction functions to map objects into points in /-dimensional space; thus, we can use highly fine-tuned database spatial access methods to accelerate the search. The remainder of the chapter is organized as follows. Section 12.2 gives some background material on past related work on spatial access methods. Section 12.3 describes the main ideas for GEMINI, a generic approach to indexing multimedia objects. Section 12.4 shows the application of the approach for ID time series indexing.   Section 12.5 gives another case study, for color images. BACKGROUND ó SPATIAL ACCESS METHODS        347 within the QBIC project. Section 12.6 presents 'FastMap', a method to do automatic feature extraction. Section 12.7 summarizes the conclusions and lists problems for future research and section 12.8 provides pointers to the related bibliography.  