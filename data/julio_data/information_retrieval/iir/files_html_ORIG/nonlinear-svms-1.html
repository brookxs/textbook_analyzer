<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<html>
 <head> 
  <title>Nonlinear SVMs</title> 
  <meta name="description" content="Nonlinear SVMs" /> 
  <meta name="keywords" content="irbook" /> 
  <meta name="resource-type" content="document" /> 
  <meta name="distribution" content="global" /> 
  <meta name="Generator" content="LaTeX2HTML v2002-2-1" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <link rel="STYLESHEET" href="irbook.css" /> 
  <link rel="next" href="experimental-results-1.html" /> 
  <link rel="previous" href="multiclass-svms-1.html" /> 
  <link rel="up" href="extensions-to-the-svm-model-1.html" /> 
  <link rel="next" href="experimental-results-1.html" /> 
 </head> 
 <body> 
  <!--Navigation Panel--> 
  <a name="tex2html3905" href="experimental-results-1.html"> <img width="37" height="24" align="BOTTOM" border="0" alt="next" src="http://nlp.stanford.edu/IR-book/html/icons/next.png" /></a> 
  <a name="tex2html3899" href="extensions-to-the-svm-model-1.html"> <img width="26" height="24" align="BOTTOM" border="0" alt="up" src="http://nlp.stanford.edu/IR-book/html/icons/up.png" /></a> 
  <a name="tex2html3893" href="multiclass-svms-1.html"> <img width="63" height="24" align="BOTTOM" border="0" alt="previous" src="http://nlp.stanford.edu/IR-book/html/icons/prev.png" /></a> 
  <a name="tex2html3901" href="contents-1.html"> <img width="65" height="24" align="BOTTOM" border="0" alt="contents" src="http://nlp.stanford.edu/IR-book/html/icons/contents.png" /></a> 
  <a name="tex2html3903" href="index-1.html"> <img width="43" height="24" align="BOTTOM" border="0" alt="index" src="http://nlp.stanford.edu/IR-book/html/icons/index.png" /></a> 
  <br /> 
  <b> Next:</b> 
  <a name="tex2html3906" href="experimental-results-1.html">Experimental results</a> 
  <b> Up:</b> 
  <a name="tex2html3900" href="extensions-to-the-svm-model-1.html">Extensions to the SVM</a> 
  <b> Previous:</b> 
  <a name="tex2html3894" href="multiclass-svms-1.html">Multiclass SVMs</a> &nbsp; 
  <b> <a name="tex2html3902" href="contents-1.html">Contents</a></b> &nbsp; 
  <b> <a name="tex2html3904" href="index-1.html">Index</a></b> 
  <br /> 
  <br /> 
  <!--End of Navigation Panel--> 
  <h2><a name="SECTION002023000000000000000"></a><a name="sec:svm-nonlinear"></a> <a name="p:svm-nonlinear"></a> <br /> Nonlinear SVMs </h2> 
  <p> </p>
  <div align="CENTER">
   <a name="fig:svmnonlinear"></a>
   <a name="p:svmnonlinear"></a>
   <a name="22738"></a> 
   <table> 
    <caption align="BOTTOM">
     <strong>Figure 15.6:</strong> Projecting data that is not linearly separable into a higher dimensional space can make it linearly separable.
    </caption> 
    <tbody>
     <tr>
      <td><img width="516" height="475" align="BOTTOM" border="0" src="img1331.png" alt="\includegraphics[width=4.5in]{non-linear.eps}" /></td>
     </tr> 
    </tbody>
   </table> 
  </div> 
  <p> With what we have presented so far, data sets that are linearly separable (perhaps with a few exceptions or some noise) are well-handled. But what are we going to do if the data set just doesn't allow classification by a linear classifier? Let us look at a one-dimensional case. The top data set in Figure <a href="#fig:svmnonlinear">15.6</a> is straightforwardly classified by a linear classifier but the middle data set is not. We instead need to be able to pick out an interval. One way to solve this problem is to map the data on to a higher dimensional space and then to use a linear classifier in the higher dimensional space. For example, the bottom part of the figure shows that a linear separator can easily classify the data if we use a quadratic function to map the data into two dimensions (a polar coordinates projection would be another possibility). The general idea is to map the original feature space to some higher-dimensional feature space where the training set is separable. Of course, we would want to do so in ways that preserve relevant dimensions of relatedness between data points, so that the resultant classifier should still generalize well. </p>
  <p> SVMs, and also a number of other linear classifiers, provide an easy and efficient way of doing this mapping to a higher dimensional space, which is referred to as ``the <a name="22743"></a> <i>kernel trick</i> ''. It's not really a trick: it just exploits the math that we have seen. The SVM linear classifier relies on a dot product between data point vectors. Let 
   <!-- MATH
 $K(\vec{x}_i, \vec{x}_j) = \vec{x}_i^{T}\vec{x}_j$
 --> <img width="115" height="38" align="MIDDLE" border="0" src="img1332.png" alt="$K(\vec{x}_i, \vec{x}_j) = \vec{x}_i^{T}\vec{x}_j$" />. Then the classifier we have seen so far is: <br /> </p>
  <div align="RIGHT"> 
   <!-- MATH
 \begin{equation}
f(\vec{x}) = \mbox{sign}(\sum_i \alpha_i y_i K(\vec{x}_i, \vec{x}) + b)
\end{equation}
 --> 
   <table width="100%" align="CENTER"> 
    <tbody>
     <tr valign="MIDDLE">
      <td align="CENTER" nowrap=""><a name="kernel-svm"></a><img width="222" height="43" border="0" src="img1333.png" alt="\begin{displaymath}
f(\vec{x}) = \mbox{sign}(\sum_i \alpha_i y_i K(\vec{x}_i, \vec{x}) + b)
\end{displaymath}" /></td> 
      <td width="10" align="RIGHT"> (172)</td>
     </tr> 
    </tbody>
   </table> 
   <br clear="ALL" />
  </div>
  <p></p> Now suppose we decide to map every data point into a higher dimensional space via some transformation 
  <!-- MATH
 $\Phi\colon \vec{x} \mapsto
\phi(\vec{x})$
 --> 
  <img width="90" height="33" align="MIDDLE" border="0" src="img1334.png" alt="$\Phi\colon \vec{x} \mapsto
\phi(\vec{x})$" />. Then the dot product becomes 
  <!-- MATH
 $\phi(\vec{x}_i)^{T}\phi(\vec{x}_j)$
 --> 
  <img width="86" height="38" align="MIDDLE" border="0" src="img1335.png" alt="$\phi(\vec{x}_i)^{T}\phi(\vec{x}_j)$" />. If it turned out that this dot product (which is just a real number) could be computed simply and efficiently in terms of the original data points, then we wouldn't have to actually map from 
  <!-- MATH
 $\vec{x} \mapsto \phi(\vec{x})$
 --> 
  <img width="71" height="33" align="MIDDLE" border="0" src="img1336.png" alt="$\vec{x} \mapsto \phi(\vec{x})$" />. Rather, we could simply compute the quantity 
  <!-- MATH
 $K(\vec{x}_i, \vec{x}_j) = 
\phi(\vec{x}_i)^{T}\phi(\vec{x}_j)$
 --> 
  <img width="167" height="38" align="MIDDLE" border="0" src="img1337.png" alt="$K(\vec{x}_i, \vec{x}_j) =
\phi(\vec{x}_i)^{T}\phi(\vec{x}_j)$" />, and then use the function's value in Equation&nbsp;
  <a href="#kernel-svm">172</a>. A 
  <a name="22770"></a> 
  <i>kernel function</i> 
  <img width="15" height="32" align="MIDDLE" border="0" src="img30.png" alt="$K$" /> is such a function that corresponds to a dot product in some expanded feature space. 
  <p> <b>Worked example.</b> The quadratic kernel in two dimensions.quad-kernel For 2-dimensional vectors 
   <!-- MATH
 $\vec{u}=(u_1\;\;u_2)$
 --> <img width="90" height="33" align="MIDDLE" border="0" src="img1338.png" alt="$\vec{u}=(u_1\;\;u_2)$" />, 
   <!-- MATH
 $\vec{v} = (v_1\;\;v_2)$
 --> <img width="87" height="33" align="MIDDLE" border="0" src="img1339.png" alt="$\vec{v} = (v_1\;\;v_2)$" />, consider 
   <!-- MATH
 $K(\vec{u}, \vec{v}) = (1 + \vec{u}^{T}\vec{v})^2$
 --> <img width="149" height="38" align="MIDDLE" border="0" src="img1340.png" alt="$K(\vec{u}, \vec{v}) = (1 + \vec{u}^{T}\vec{v})^2$" />. We wish to show that this is a kernel, i.e., that 
   <!-- MATH
 $K(\vec{u}, \vec{v}) = \phi(\vec{u})^{T}\phi(\vec{v})$
 --> <img width="149" height="38" align="MIDDLE" border="0" src="img1341.png" alt="$K(\vec{u}, \vec{v}) = \phi(\vec{u})^{T}\phi(\vec{v})$" /> for some <img width="13" height="32" align="MIDDLE" border="0" src="img1342.png" alt="$\phi$" />. Consider 
   <!-- MATH
 $\phi(\vec{u}) = (1\;\; u_1^2\;\; \sqrt{2}u_1u_2\;\; u_2^2\;\; \sqrt{2}
u_1\;\; \sqrt{2}u_2)$
 --> <img width="288" height="38" align="MIDDLE" border="0" src="img1343.png" alt="$\phi(\vec{u}) = (1\;\; u_1^2\;\; \sqrt{2}u_1u_2\;\; u_2^2\;\; \sqrt{2}
u_1\;\; \sqrt{2}u_2)$" />. Then: <br /> </p>
  <div align="CENTER">
   <a name="2d-poly-kernel"></a> 
   <!-- MATH
 \begin{eqnarray}
K(\vec{u}, \vec{v}) &=&
(1+\vec{u}^{T}\vec{v})^2\\
 &=&
1+u_{1}^2v_{1}^2 + 2 u_{1}v_{1}u_{2}v_{2}+ u_{2}^2v_{2}^2 +
2u_{1}v_{1} + 2u_{2}v_{2}  \\
& = & (1\;\; u_{1}^2\;\; \sqrt2u_{1}u_{2}\;\; u_{2}^2\;\; \sqrt{2}u_{1} \;\;
\sqrt{2}u_{2})^{T} 
(1\;\; v_{1}^2\;\; \sqrt{2}v_{1}v_{2}\;\; v_{2}^2\;\; \sqrt{2}v_{1} \;\;
\sqrt{2}v_{2})  \\
& = & \phi(\vec{u})^{T}\phi(\vec{v})
\end{eqnarray}
 --> 
   <table align="CENTER" cellpadding="0" width="100%"> 
    <tbody>
     <tr valign="MIDDLE">
      <td nowrap="" align="RIGHT"><img width="53" height="33" align="MIDDLE" border="0" src="img1344.png" alt="$\displaystyle K(\vec{u}, \vec{v})$" /></td> 
      <td align="CENTER" nowrap=""><img width="17" height="32" align="MIDDLE" border="0" src="img313.png" alt="$\textstyle =$" /></td> 
      <td align="LEFT" nowrap=""><img width="78" height="38" align="MIDDLE" border="0" src="img1345.png" alt="$\displaystyle (1+\vec{u}^{T}\vec{v})^2$" /></td> 
      <td width="10" align="RIGHT"> (173)</td>
     </tr> 
     <tr valign="MIDDLE">
      <td nowrap="" align="RIGHT">&nbsp;</td> 
      <td align="CENTER" nowrap=""><img width="17" height="32" align="MIDDLE" border="0" src="img313.png" alt="$\textstyle =$" /></td> 
      <td align="LEFT" nowrap=""><img width="321" height="38" align="MIDDLE" border="0" src="img1346.png" alt="$\displaystyle 1+u_{1}^2v_{1}^2 + 2 u_{1}v_{1}u_{2}v_{2}+ u_{2}^2v_{2}^2 +
2u_{1}v_{1} + 2u_{2}v_{2}$" /></td> 
      <td width="10" align="RIGHT"> (174)</td>
     </tr> 
     <tr valign="MIDDLE">
      <td nowrap="" align="RIGHT">&nbsp;</td> 
      <td align="CENTER" nowrap=""><img width="17" height="32" align="MIDDLE" border="0" src="img313.png" alt="$\textstyle =$" /></td> 
      <td align="LEFT" nowrap=""><img width="465" height="40" align="MIDDLE" border="0" src="img1347.png" alt="$\displaystyle (1\;\; u_{1}^2\;\; \sqrt2u_{1}u_{2}\;\; u_{2}^2\;\; \sqrt{2}u_{1}...
..._{1}^2\;\; \sqrt{2}v_{1}v_{2}\;\; v_{2}^2\;\; \sqrt{2}v_{1} \;\;
\sqrt{2}v_{2})$" /></td> 
      <td width="10" align="RIGHT"> (175)</td>
     </tr> 
     <tr valign="MIDDLE">
      <td nowrap="" align="RIGHT">&nbsp;</td> 
      <td align="CENTER" nowrap=""><img width="17" height="32" align="MIDDLE" border="0" src="img313.png" alt="$\textstyle =$" /></td> 
      <td align="LEFT" nowrap=""><img width="77" height="38" align="MIDDLE" border="0" src="img1348.png" alt="$\displaystyle \phi(\vec{u})^{T}\phi(\vec{v})$" /></td> 
      <td width="10" align="RIGHT"> (176)</td>
     </tr> 
    </tbody>
   </table>
  </div> 
  <br clear="ALL" />
  <p></p> 
  <b>End worked example.</b> 
  <p> In the language of functional analysis, what kinds of functions are valid <a name="22833"></a> <i>kernel functions</i> ? Kernel functions are sometimes more precisely referred to as <a name="22835"></a> <i>Mercer kernels</i> , because they must satisfy Mercer's condition: for any <img width="35" height="33" align="MIDDLE" border="0" src="img1349.png" alt="$g(\vec{x})$" /> such that 
   <!-- MATH
 $\int g(\vec{x})^2 d\vec{x}$
 --> <img width="73" height="36" align="MIDDLE" border="0" src="img1350.png" alt="$\int g(\vec{x})^2 d\vec{x}$" /> is finite, we must have that: <br /> </p>
  <div align="RIGHT"> 
   <!-- MATH
 \begin{equation}
\int K(\vec{x}, \vec{z})g(\vec{x})g(\vec{z})d\vec{x}d\vec{z} \ge 0\thinspace.
\end{equation}
 --> 
   <table width="100%" align="CENTER"> 
    <tbody>
     <tr valign="MIDDLE">
      <td align="CENTER" nowrap=""><img width="195" height="38" border="0" src="img1351.png" alt="\begin{displaymath}
\int K(\vec{x}, \vec{z})g(\vec{x})g(\vec{z})d\vec{x}d\vec{z} \ge 0\thinspace.
\end{displaymath}" /></td> 
      <td width="10" align="RIGHT"> (177)</td>
     </tr> 
    </tbody>
   </table> 
   <br clear="ALL" />
  </div>
  <p></p> A kernel function 
  <img width="15" height="32" align="MIDDLE" border="0" src="img30.png" alt="$K$" /> must be continuous, symmetric, and have a positive definite gram matrix. Such a 
  <img width="15" height="32" align="MIDDLE" border="0" src="img30.png" alt="$K$" /> means that there exists a mapping to a reproducing kernel Hilbert space (a Hilbert space is a vector space closed under dot products) such that the dot product there gives the same value as the function 
  <img width="15" height="32" align="MIDDLE" border="0" src="img30.png" alt="$K$" />. If a kernel does not satisfy Mercer's condition, then the corresponding QP may have no solution. If you would like to better understand these issues, you should consult the books on SVMs mentioned in Section 
  <a href="references-and-further-reading-15.html#sec:svm-refs">15.5</a> . Otherwise, you can content yourself with knowing that 90% of work with kernels uses one of two straightforward families of functions of two vectors, which we define below, and which define valid kernels. 
  <p> The two commonly used families of kernels are polynomial kernels and radial basis functions. Polynomial kernels are of the form 
   <!-- MATH
 $K(\vec{x},\vec{z}) =
(1+\vec{x}^{T}\vec{z})^d$
 --> <img width="147" height="37" align="MIDDLE" border="0" src="img1352.png" alt="$K(\vec{x},\vec{z}) =
(1+\vec{x}^{T}\vec{z})^d$" />. The case of <img width="42" height="31" align="MIDDLE" border="0" src="img1353.png" alt="$d = 1$" /> is a linear kernel, which is what we had before the start of this section (the constant 1 just changing the threshold). The case of <img width="42" height="31" align="MIDDLE" border="0" src="img1354.png" alt="$d = 2$" /> gives a quadratic kernel, and is very commonly used. We illustrated the quadratic kernel in quad-kernel. </p>
  <p> The most common form of radial basis function is a Gaussian distribution, calculated as: <br /> </p>
  <div align="RIGHT"> 
   <!-- MATH
 \begin{equation}
K(\vec{x},\vec{z}) = e^{-(\vec{x}-\vec{z})^2/(2\sigma^2)}
\end{equation}
 --> 
   <table width="100%" align="CENTER"> 
    <tbody>
     <tr valign="MIDDLE">
      <td align="CENTER" nowrap=""><img width="161" height="28" border="0" src="img1355.png" alt="\begin{displaymath}
K(\vec{x},\vec{z}) = e^{-(\vec{x}-\vec{z})^2/(2\sigma^2)}
\end{displaymath}" /></td> 
      <td width="10" align="RIGHT"> (178)</td>
     </tr> 
    </tbody>
   </table> 
   <br clear="ALL" />
  </div>
  <p></p> A radial basis function (rbf) is equivalent to mapping the data into an infinite dimensional Hilbert space, and so we cannot illustrate the radial basis function concretely, as we did a quadratic kernel. Beyond these two families, there has been interesting work developing other kernels, some of which is promising for text applications. In particular, there has been investigation of string kernels (see Section 
  <a href="references-and-further-reading-15.html#sec:svm-refs">15.5</a> ). 
  <p> The world of SVMs comes with its own language, which is rather different from the language otherwise used in machine learning. The terminology does have deep roots in mathematics, but it's important not to be too awed by that terminology. Really, we are talking about some quite simple things. A polynomial kernel allows us to model feature conjunctions (up to the order of the polynomial). That is, if we want to be able to model occurrences of pairs of words, which give distinctive information about topic classification, not given by the individual words alone, like perhaps <i>operating</i> and <i>system</i> or <i>ethnic</i> and <i>cleansing</i>, then we need to use a quadratic kernel. If occurrences of triples of words give distinctive information, then we need to use a cubic kernel. Simultaneously you also get the powers of the basic features - for most text applications, that probably isn't useful, but just comes along with the math and hopefully doesn't do harm. A radial basis function allows you to have features that pick out circles (hyperspheres) - although the decision boundaries become much more complex as multiple such features interact. A string kernel lets you have features that are character subsequences of terms. All of these are straightforward notions which have also been used in many other places under different names. </p>
  <p> </p>
  <hr /> 
  <!--Navigation Panel--> 
  <a name="tex2html3905" href="experimental-results-1.html"> <img width="37" height="24" align="BOTTOM" border="0" alt="next" src="http://nlp.stanford.edu/IR-book/html/icons/next.png" /></a> 
  <a name="tex2html3899" href="extensions-to-the-svm-model-1.html"> <img width="26" height="24" align="BOTTOM" border="0" alt="up" src="http://nlp.stanford.edu/IR-book/html/icons/up.png" /></a> 
  <a name="tex2html3893" href="multiclass-svms-1.html"> <img width="63" height="24" align="BOTTOM" border="0" alt="previous" src="http://nlp.stanford.edu/IR-book/html/icons/prev.png" /></a> 
  <a name="tex2html3901" href="contents-1.html"> <img width="65" height="24" align="BOTTOM" border="0" alt="contents" src="http://nlp.stanford.edu/IR-book/html/icons/contents.png" /></a> 
  <a name="tex2html3903" href="index-1.html"> <img width="43" height="24" align="BOTTOM" border="0" alt="index" src="http://nlp.stanford.edu/IR-book/html/icons/index.png" /></a> 
  <br /> 
  <b> Next:</b> 
  <a name="tex2html3906" href="experimental-results-1.html">Experimental results</a> 
  <b> Up:</b> 
  <a name="tex2html3900" href="extensions-to-the-svm-model-1.html">Extensions to the SVM</a> 
  <b> Previous:</b> 
  <a name="tex2html3894" href="multiclass-svms-1.html">Multiclass SVMs</a> &nbsp; 
  <b> <a name="tex2html3902" href="contents-1.html">Contents</a></b> &nbsp; 
  <b> <a name="tex2html3904" href="index-1.html">Index</a></b> 
  <!--End of Navigation Panel--> 
  <address> &copy; 2008 Cambridge University Press<br />This is an automatically generated page. In case of formatting errors you may want to look at the <a href="http://informationretrieval.org">PDF edition</a> of the book.<br /> 2009-04-07 </address>   
 </body>
</html>