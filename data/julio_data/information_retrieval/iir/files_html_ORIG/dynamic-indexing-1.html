<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<html>
 <head> 
  <title>Dynamic indexing</title> 
  <meta name="description" content="Dynamic indexing" /> 
  <meta name="keywords" content="irbook" /> 
  <meta name="resource-type" content="document" /> 
  <meta name="distribution" content="global" /> 
  <meta name="Generator" content="LaTeX2HTML v2002-2-1" /> 
  <meta http-equiv="Content-Style-Type" content="text/css" /> 
  <link rel="STYLESHEET" href="irbook.css" /> 
  <link rel="next" href="other-types-of-indexes-1.html" /> 
  <link rel="previous" href="distributed-indexing-1.html" /> 
  <link rel="up" href="index-construction-1.html" /> 
  <link rel="next" href="other-types-of-indexes-1.html" /> 
 </head> 
 <body> 
  <!--Navigation Panel--> 
  <a name="tex2html1613" href="other-types-of-indexes-1.html"> <img width="37" height="24" align="BOTTOM" border="0" alt="next" src="http://nlp.stanford.edu/IR-book/html/icons/next.png" /></a> 
  <a name="tex2html1607" href="index-construction-1.html"> <img width="26" height="24" align="BOTTOM" border="0" alt="up" src="http://nlp.stanford.edu/IR-book/html/icons/up.png" /></a> 
  <a name="tex2html1601" href="distributed-indexing-1.html"> <img width="63" height="24" align="BOTTOM" border="0" alt="previous" src="http://nlp.stanford.edu/IR-book/html/icons/prev.png" /></a> 
  <a name="tex2html1609" href="contents-1.html"> <img width="65" height="24" align="BOTTOM" border="0" alt="contents" src="http://nlp.stanford.edu/IR-book/html/icons/contents.png" /></a> 
  <a name="tex2html1611" href="index-1.html"> <img width="43" height="24" align="BOTTOM" border="0" alt="index" src="http://nlp.stanford.edu/IR-book/html/icons/index.png" /></a> 
  <br /> 
  <b> Next:</b> 
  <a name="tex2html1614" href="other-types-of-indexes-1.html">Other types of indexes</a> 
  <b> Up:</b> 
  <a name="tex2html1608" href="index-construction-1.html">Index construction</a> 
  <b> Previous:</b> 
  <a name="tex2html1602" href="distributed-indexing-1.html">Distributed indexing</a> &nbsp; 
  <b> <a name="tex2html1610" href="contents-1.html">Contents</a></b> &nbsp; 
  <b> <a name="tex2html1612" href="index-1.html">Index</a></b> 
  <br /> 
  <br /> 
  <!--End of Navigation Panel--> 
  <h1><a name="SECTION00950000000000000000"></a> <a name="sec:dynamicindexing"></a> <a name="p:dynamicindexing"></a> <br /> Dynamic indexing </h1> 
  <p> Thus far, we have assumed that the document collection is static. This is fine for collections that change infrequently or never (e.g., the Bible or Shakespeare). But most collections are modified frequently with documents being added, deleted, and updated. This means that new terms need to be added to the dictionary, and postings lists need to be updated for existing terms. </p>
  <p> The simplest way to achieve this is to periodically reconstruct the index from scratch. This is a good solution if the number of changes over time is small and a delay in making new documents searchable is acceptable - and if enough resources are available to construct a new index while the old one is still available for querying. </p>
  <p> If there is a requirement that new documents be included quickly, one solution is to maintain two indexes: a large main index and a small <a name="5167"></a><a name="5168"></a> <i>auxiliary index</i> that stores new documents. The auxiliary index is kept in memory. Searches are run across both indexes and results merged. Deletions are stored in an invalidation bit vector. We can then filter out deleted documents before returning the search result. Documents are updated by deleting and reinserting them. </p>
  <p> Each time the auxiliary index becomes too large, we merge it into the main index. The cost of this merging operation depends on how we store the index in the file system. If we store each postings list as a separate file, then the merge simply consists of extending each postings list of the main index by the corresponding postings list of the auxiliary index. In this scheme, the reason for keeping the auxiliary index is to reduce the number of disk seeks required over time. Updating each document separately requires up to <img width="38" height="32" align="MIDDLE" border="0" src="img203.png" alt="$ M_{ave}$" /><a name="Md-notation"></a>disk seeks, where <img width="38" height="32" align="MIDDLE" border="0" src="img203.png" alt="$ M_{ave}$" /> is the average size of the vocabulary of documents in the collection. With an auxiliary index, we only put additional load on the disk when we merge auxiliary and main indexes. </p>
  <p> Unfortunately, the one-file-per-postings-list scheme is infeasible because most file systems cannot efficiently handle very large numbers of files. The simplest alternative is to store the index as one large file, that is, as a concatenation of all postings lists. In reality, we often choose a compromise between the two extremes (Section <a href="references-and-further-reading-4.html#sec:iconstfurther">4.7</a> ). To simplify the discussion, we choose the simple option of storing the index as one large file here. </p>
  <p> In this scheme, we process each posting 
   <!-- MATH
 $\lfloor T/n
\rfloor$
 --> <img width="49" height="33" align="MIDDLE" border="0" src="img204.png" alt="$\lfloor T/n
\rfloor$" /> times because we touch it during each of 
   <!-- MATH
 $\lfloor
T/n \rfloor$
 --> <img width="49" height="33" align="MIDDLE" border="0" src="img204.png" alt="$\lfloor T/n
\rfloor$" /> merges where <img width="13" height="32" align="MIDDLE" border="0" src="img104.png" alt="$n$" /> is the size of the auxiliary index and <img width="15" height="32" align="MIDDLE" border="0" src="img123.png" alt="$T$" /> the total number of postings. Thus, the overall time complexity is <img width="67" height="36" align="MIDDLE" border="0" src="img205.png" alt="$\Theta(T^2/n)$" />. (We neglect the representation of terms here and consider only the docIDs. For the purpose of time complexity, a postings list is simply a list of docIDs.) </p>
  <p> </p>
  <div align="CENTER">
   <a name="fig:logmerging"></a>
   <a name="p:logmerging"></a>
   <a name="5360"></a> 
   <table> 
    <caption align="BOTTOM">
     <strong>Figure:</strong> Logarithmic merging.
     <a name="5204"></a> Each token (termID,docID) is initially added to in-memory index 
     <img width="22" height="32" align="MIDDLE" border="0" src="img5.png" alt="$Z_0$" /> by LM
     <small>ERGE</small>A
     <small>DD</small>T
     <small>OKEN</small>. L
     <small>OGARITHMIC</small>M
     <small>ERGE</small> initializes 
     <img width="22" height="32" align="MIDDLE" border="0" src="img5.png" alt="$Z_0$" /> and 
     <img width="55" height="31" align="MIDDLE" border="0" src="img6.png" alt="$indexes$" />.
    </caption> 
    <tbody>
     <tr>
      <td><img width="470" height="341" border="0" src="img206.png" alt="\begin{figure}\begin{algorithm}{LMergeAddToken}{indexes,Z_0,token}
Z_0 \= \CALL{...
...oken}(indexes,Z_0,\CALL{getNextToken}())
\end{WHILE}\end{algorithm}
\end{figure}" /></td>
     </tr> 
    </tbody>
   </table> 
  </div> 
  <p> We can do better than <img width="67" height="36" align="MIDDLE" border="0" src="img205.png" alt="$\Theta(T^2/n)$" /> by introducing <img width="77" height="33" align="MIDDLE" border="0" src="img207.png" alt="$\log_2 (T/n)$" /> indexes <img width="17" height="32" align="MIDDLE" border="0" src="img208.png" alt="$I_0$" />, <img width="17" height="32" align="MIDDLE" border="0" src="img209.png" alt="$I_1$" />, <img width="17" height="32" align="MIDDLE" border="0" src="img210.png" alt="$I_2$" />, ...of size <img width="48" height="36" align="MIDDLE" border="0" src="img211.png" alt="$2^0 \times n$" />, <img width="47" height="38" align="MIDDLE" border="0" src="img212.png" alt="$2^1 \times n$" />, <img width="48" height="36" align="MIDDLE" border="0" src="img213.png" alt="$2^2 \times n$" /> .... Postings percolate up this sequence of indexes and are processed only once on each level. This scheme is called <a name="5210"></a> <i>logarithmic merging</i> (Figure <a href="#fig:logmerging">4.7</a> ). As before, up to <img width="13" height="32" align="MIDDLE" border="0" src="img104.png" alt="$n$" /> postings are accumulated in an in-memory auxiliary index, which we call <img width="22" height="32" align="MIDDLE" border="0" src="img5.png" alt="$Z_0$" />. When the limit <img width="13" height="32" align="MIDDLE" border="0" src="img104.png" alt="$n$" /> is reached, the <img width="48" height="36" align="MIDDLE" border="0" src="img211.png" alt="$2^0 \times n$" /> postings in <img width="22" height="32" align="MIDDLE" border="0" src="img5.png" alt="$Z_0$" /> are transferred to a new index <img width="17" height="32" align="MIDDLE" border="0" src="img208.png" alt="$I_0$" /> that is created on disk. The next time <img width="22" height="32" align="MIDDLE" border="0" src="img5.png" alt="$Z_0$" /> is full, it is merged with <img width="17" height="32" align="MIDDLE" border="0" src="img208.png" alt="$I_0$" /> to create an index <img width="21" height="32" align="MIDDLE" border="0" src="img214.png" alt="$Z_1$" /> of size 
   <!-- MATH
 $2^1\!  \times n$
 --> <img width="45" height="38" align="MIDDLE" border="0" src="img215.png" alt="$2^1\! \times n$" />. Then <img width="21" height="32" align="MIDDLE" border="0" src="img214.png" alt="$Z_1$" /> is either stored as <img width="17" height="32" align="MIDDLE" border="0" src="img209.png" alt="$I_1$" /> (if there isn't already an <img width="17" height="32" align="MIDDLE" border="0" src="img209.png" alt="$I_1$" />) or merged with <img width="17" height="32" align="MIDDLE" border="0" src="img209.png" alt="$I_1$" /> into <img width="21" height="32" align="MIDDLE" border="0" src="img216.png" alt="$Z_2$" /> (if <img width="17" height="32" align="MIDDLE" border="0" src="img209.png" alt="$I_1$" /> exists); and so on. We service search requests by querying in-memory <img width="22" height="32" align="MIDDLE" border="0" src="img5.png" alt="$Z_0$" /> and all currently valid indexes <img width="15" height="32" align="MIDDLE" border="0" src="img217.png" alt="$I_i$" /> on disk and merging the results. Readers familiar with the binomial heap data structure<a name="tex2html42" href="footnode.html#foot5361"><sup><img align="BOTTOM" border="1" alt="[*]" src="http://nlp.stanford.edu/IR-book/html/icons/footnote.png" /></sup></a> will recognize its similarity with the structure of the inverted indexes in logarithmic merging. </p>
  <p> Overall index construction time is 
   <!-- MATH
 $\Theta(T \log (T/n))$
 --> <img width="109" height="33" align="MIDDLE" border="0" src="img218.png" alt="$\Theta(T \log (T/n))$" /> because each posting is processed only once on each of the <img width="70" height="33" align="MIDDLE" border="0" src="img219.png" alt="$\log (T/n)$" /> levels. We trade this efficiency gain for a slow down of query processing; we now need to merge results from <img width="70" height="33" align="MIDDLE" border="0" src="img219.png" alt="$\log (T/n)$" /> indexes as opposed to just two (the main and auxiliary indexes). As in the auxiliary index scheme, we still need to merge very large indexes occasionally (which slows down the search system during the merge), but this happens less frequently and the indexes involved in a merge on average are smaller. </p>
  <p> Having multiple indexes complicates the maintenance of collection-wide <a name="p:auxstatistics"></a> statistics. For example, it affects the spelling correction algorithm in Section&nbsp;<a href="spelling-correction-1.html#sec:spelling">3.3</a> (page&nbsp;<a href="spelling-correction-1.html#p:spelling"><img align="BOTTOM" border="1" alt="[*]" src="http://nlp.stanford.edu/IR-book/html/icons/crossref.png" /></a>) that selects the corrected alternative with the most hits. With multiple indexes and an invalidation bit vector, the correct number of hits for a term is no longer a simple lookup. In fact, all aspects of an IR system - index maintenance, query processing, distribution, and so on - are more complex in logarithmic merging. </p>
  <p> Because of this complexity of dynamic indexing, some large search engines adopt a reconstruction-from-scratch strategy. They do not construct indexes dynamically. Instead, a new index is built from scratch periodically. Query processing is then switched from the new index and the old index is deleted. </p>
  <p> <b>Exercises.</b> </p>
  <ul> 
   <li>For <img width="43" height="32" align="MIDDLE" border="0" src="img220.png" alt="$n=2$" /> and 
    <!-- MATH
 $1 \leq T \leq 30$
 --> <img width="83" height="32" align="MIDDLE" border="0" src="img221.png" alt="$1 \leq T \leq 30$" />, perform a step-by-step simulation of the algorithm in Figure <a href="#fig:logmerging">4.7</a> . Create a table that shows, for each point in time at which <img width="67" height="31" align="MIDDLE" border="0" src="img222.png" alt="$T=2*k$" /> tokens have been processed (
    <!-- MATH
 $1 \leq k \leq
15$
 --> <img width="80" height="31" align="MIDDLE" border="0" src="img223.png" alt="$1 \leq k \leq
15$" />), which of the three indexes 
    <!-- MATH
 $I_0, \ldots, I_3$
 --> <img width="64" height="32" align="MIDDLE" border="0" src="img224.png" alt="$I_0, \ldots, I_3$" /> are in use. The first three lines of the table are given below. 
    <blockquote> 
     <table cellpadding="3" border="1"> 
      <tbody>
       <tr>
        <td align="LEFT">&nbsp;</td>
        <td align="LEFT">&nbsp;</td> 
        <td align="LEFT"><img width="17" height="32" align="MIDDLE" border="0" src="img225.png" alt="$I_3$" /></td> 
        <td align="LEFT"><img width="17" height="32" align="MIDDLE" border="0" src="img210.png" alt="$I_2$" /></td> 
        <td align="LEFT"><img width="17" height="32" align="MIDDLE" border="0" src="img209.png" alt="$I_1$" /></td> 
        <td align="LEFT"><img width="17" height="32" align="MIDDLE" border="0" src="img208.png" alt="$I_0$" /></td> 
        <td align="LEFT">&nbsp;</td>
       </tr> 
       <tr>
        <td align="LEFT">&nbsp;</td>
        <td align="LEFT">2</td> 
        <td align="LEFT">0</td> 
        <td align="LEFT">0</td> 
        <td align="LEFT">0</td> 
        <td align="LEFT">0</td> 
        <td align="LEFT">&nbsp;</td>
       </tr> 
       <tr>
        <td align="LEFT">&nbsp;</td>
        <td align="LEFT">4</td> 
        <td align="LEFT">0</td> 
        <td align="LEFT">0</td> 
        <td align="LEFT">0</td> 
        <td align="LEFT">1</td> 
        <td align="LEFT">&nbsp;</td>
       </tr> 
       <tr>
        <td align="LEFT">&nbsp;</td>
        <td align="LEFT">6</td> 
        <td align="LEFT">0</td> 
        <td align="LEFT">0</td> 
        <td align="LEFT">1</td> 
        <td align="LEFT">0</td> 
        <td align="LEFT">&nbsp;</td>
       </tr> 
      </tbody>
     </table> 
    </blockquote> <p> </p></li> 
  </ul> 
  <p> </p>
  <hr /> 
  <!--Navigation Panel--> 
  <a name="tex2html1613" href="other-types-of-indexes-1.html"> <img width="37" height="24" align="BOTTOM" border="0" alt="next" src="http://nlp.stanford.edu/IR-book/html/icons/next.png" /></a> 
  <a name="tex2html1607" href="index-construction-1.html"> <img width="26" height="24" align="BOTTOM" border="0" alt="up" src="http://nlp.stanford.edu/IR-book/html/icons/up.png" /></a> 
  <a name="tex2html1601" href="distributed-indexing-1.html"> <img width="63" height="24" align="BOTTOM" border="0" alt="previous" src="http://nlp.stanford.edu/IR-book/html/icons/prev.png" /></a> 
  <a name="tex2html1609" href="contents-1.html"> <img width="65" height="24" align="BOTTOM" border="0" alt="contents" src="http://nlp.stanford.edu/IR-book/html/icons/contents.png" /></a> 
  <a name="tex2html1611" href="index-1.html"> <img width="43" height="24" align="BOTTOM" border="0" alt="index" src="http://nlp.stanford.edu/IR-book/html/icons/index.png" /></a> 
  <br /> 
  <b> Next:</b> 
  <a name="tex2html1614" href="other-types-of-indexes-1.html">Other types of indexes</a> 
  <b> Up:</b> 
  <a name="tex2html1608" href="index-construction-1.html">Index construction</a> 
  <b> Previous:</b> 
  <a name="tex2html1602" href="distributed-indexing-1.html">Distributed indexing</a> &nbsp; 
  <b> <a name="tex2html1610" href="contents-1.html">Contents</a></b> &nbsp; 
  <b> <a name="tex2html1612" href="index-1.html">Index</a></b> 
  <!--End of Navigation Panel--> 
  <address> &copy; 2008 Cambridge University Press<br />This is an automatically generated page. In case of formatting errors you may want to look at the <a href="http://informationretrieval.org">PDF edition</a> of the book.<br /> 2009-04-07 </address>   
 </body>
</html>